54acd76f7207c6a2880012bb


def decode_morse(whatever)
  whatever
end

def decode_bits_advanced(bits)
  bits = bits.gsub(/^0+|0+$/, '')
  arr_bits = bits.scan(/1+|0+/).map(&:size).sort
  arr_bits = k_means_sort(arr_bits).map(&:uniq)#.map(&:reverse).reverse
  return "" if arr_bits.empty?

  # if there is only one group, it must be a .

  # deal with missing groups
  p arr_bits
  if arr_bits.size < 2
    arr_bits << [] << []
  elsif arr_bits.size < 3 && arr_bits[0].sum.to_f / arr_bits[0].size.to_f * 4.0 < arr_bits[1].sum.to_f / arr_bits[1].size.to_f #insert an empty middle if there is a big gap
    arr_bits.insert(1, [])
  elsif arr_bits.size < 3 
    arr_bits.insert(2, []) #insert an empty end otherwise
  end
  #p arr_bits = [[1, 2, 3, 4, 5, 6, 7], [ 8, 9, 10, 11, 12, 13, 14, 15, 16], [ 18, 19, 20, 21, 22, 23, 24, 25, 26, 28]]
  raise "Less than 3 groupings #{arr_bits}" if arr_bits.size < 3
  search =  arr_bits.map{ |arr| Regexp.new(arr.map { |time| "0" * time }.reverse.join("|")) }
  
  bits.split(search[2] != // ? search[2] : nil).map do |word|
    word.split(search[1] != // ? search[1] : nil).map do |character|
      "character = #{character}"
      character = character.split(/0+/).map do |morse|
        morse
        arr_bits[0].include?(morse.length) ? "." : "-"
      end.join('')
      MORSE_CODE[character]
    end.join('')
  end.join(' ')

end

def k_means_sort(items, number_of_centroids = [items.uniq.length, 3].min)
  items.sort!
  centroids = nil

  case number_of_centroids
  when 0
    return []
  when 1
    next_centroids = [items[0]]
  when 2
    next_centroids = [items[0], items[-1]]
  else
    next_centroids = [items[[0, items[-1]/2].max], items[-1]/1.5, items[-1]]
  end
  p next_centroids
  groups = Array.new(number_of_centroids, []).map(&:dup)

  until centroids == next_centroids
    groups.each(&:clear)
    centroids = next_centroids

    items.each_with_index do |item, i|
      closest_index, lowest_value = nil, 1000000

      centroids.each_with_index do |centroid, j|
        if (centroid - item + items.size / 1200.0 ).abs < lowest_value
          closest_index, lowest_value = j, (centroid - item  + items.size / 1200.0 ).abs
        end
      end

      groups[closest_index] << item
    end

    next_centroids = groups.map { |arr| arr.sum / arr.size.to_f }
  end

  p groups
end
_______________________________________________
# MORSE_CODE is preloaded
def stats(bits)
  # If all zeros
  return nil if !bits.include? '1'
  
  # Get min and max ones length
  min, max = bits.split('0').reject(&:empty?).minmax.map(&:size)
  
  # Get the minimum zeros length
  zero = bits.split('1').reject(&:empty?).min&.size
  
  # If they are equal check zeros
  return min if min === max && (!zero || zero === min)
  return (zero.to_f / 7).floor(1) if min === max && zero > min && (zero.to_f / 7).floor(1) > 0.5
  return [min, zero.to_f / 3].min if min === max && zero > min
  return zero if min === max && zero < min
  return min if min === max
  
  # Else assume statistical distribution
  zerom = bits.split('1').reject(&:empty?).max&.size
  # Average is not the best but it'll do
  ave = (min + max).to_f / 2

  # Check relation between minimum and average
  return min if ave < min * 3
  return ave.floor.to_f / 3 + (ave > min * 7 ? 0.1 : 0)
end

def decode_bits_advanced(bits)
  # Remove the initial zeros
  bits[0] = '' while bits[0] === '0'
  # Remove the final zeros
  bits[-1] = '' while bits[-1] === '0'

  # Get the shortest stroke
  dot = stats(bits)
  return '' if !dot

  # Set the dash
  dash = (dot * 3).ceil

  # Set arrays for dot and dash lengths
  dotArr = (1..dash - 1).to_a
  dashArr = (dash..(dot * 7).ceil - 1).to_a

  # Set array for gaps between words
  maxGap = bits.split('1').reject(&:empty?).max&.size
  maxGap = maxGap ? [maxGap, (dot * 7).ceil + 1].max : (dot * 7).ceil + 1
  gapArr = ((dot * 7).ceil..maxGap).to_a

  # Replace gaps between words
  gapArr.each { |l| bits.gsub!('0'*l, ' | ') }

  # Replace space and -
  dashArr.reverse.each { |l| bits.gsub!('1'*l, '-') }
  dashArr.each { |l| bits.gsub!('0'*l, ' ') }

  # Replace zeros and .
  dotArr.reverse.each { |l| bits.gsub!('1'*l, '.') }
  dotArr.reverse.each { |l| bits.gsub!('0'*l, '') }

  return bits
end

# Decode morse depending
def decode_morse(morse_code)
  morse_code.strip.split('|').map{ |i| i.split(' ').map {|j| MORSE_CODE[j]  }.join }.join(' ')
end
_______________________________________________
# MORSE_CODE is preloaded

def decode_bits_advanced(bits)
  # ToDo: Accept 0's and 1's, return dots, dashes and spaces
  min = 1/0.0
  max = 3
  
  letter = 0
  space  = 0
  pause = 6
  started = false
  #puts bits.inspect
  vals = []
  
  bits.chars.each do |c|
    
    if c == "1"
      if space > 0 && started == true
        min = [space, min].min
      end
      started = true
      pause = [pause, space].max
      letter += 1
      space = 0
    elsif letter > 0
      
      min = [letter, min].min
      max = [letter, max].max
      
      vals << letter
      letter = 0
    end
    if c == "0"
      space += 1
      
    end
  end
 
  if letter > 0
    min = [letter, min].min
    max = [letter, max].max
    vals << letter
  end
  vals = vals.uniq.sort
  if vals.size % 2 == 0
    mid = vals.size/2
  else
    mid = vals.size/2
  end
  code = []
  letter = 0
  space  = 0
  cur = ""
  
  
  
  max_letter = 0
  bits.chars.each do |c|
    if c == "1" 
      
      if space > (max/2) && space > min
        if cur.size > 0 
          code << cur
          
          if space >= (max+3) #&& space >= (pause-6) && space > 4
            max_letter = 0
            #puts "ADDED #{space}"
            code << ' '
          else
            #puts "NOT #{space}"
          end
        end
        cur = ""     
      end
       
      space = 0
      letter += 1
      max_letter = [letter, max_letter].max
    else 
      if letter > 0
        
        if letter < vals[mid] || letter == min
          cur += '.'
        else
          cur += '-'
        end
        
        letter = 0
       
      end
      space += 1
    end
  end
  
  if letter > 0
    
    if letter < vals[mid] || letter == min
      cur += '.'
    else
      cur += '-'
    end
  end
  if cur.size > 0 
    code << cur
  end
  
  
  
  
  #x = bits.gsub('111', '-').gsub('000', ' ').gsub('1', '.').gsub('0', '')
  #x = x.split(' ')
  #puts x.inspect
  
  return code
end

def decode_morse(morse_code)
 #puts "IN MORE"
  #split = morse_code.split(' ')
  #puts split.inspect
  output = ""
  #puts MORSE_CODE.inspect
  morse_code.each do |code|
    if code == ' '
      output += ' '
    else
      output +=   MORSE_CODE[code]
    end
  end
  #puts output.inspect
  return output
  
  
  
end

_______________________________________________
LOOKUP = {
  '1' => 'E',
  '101' => 'I',
  '111' => 'E',
  '1001' => 'EE',
  '10001' => 'EE',
  '10111' => 'A',
  '1110111' => 'M',
  '1111111' => 'E',
  '110011' => 'I',
  '111110000011111' => 'I',
  '10000001' => 'E E',
  '111000111' => 'I',
  '01110' => 'E',
  '000000011100000' => 'E',
  '11111000001111111000011111100000111111111111111000011111111111111000000111111111111111100001110000011111100000001111000000000000000011111111111111000000111110000011111111111111100000011110000011111111111111100001111111111111110000000000000000000000000000000000011111111111111110000000000000001111000000111110000011110000000111100000000000000111110000000000000000000000000000000000011111111111111100000111111111111111000011111000001111111111111100000000000000001111111000000111111000000011111111111111000000000000000011110000001111100000000000000011111111111111100000111111000111111111111111000011110000000000000000111111111111110000000111100000111111111111110000000000000000000000000000000000011111111111111100000111111000011111000000111110000000000000001111110000111111111111111100000011110000000000000011111111111111100001111111111111110000111111111111110000000000000001111100000001111111111111110000000111111111111111110000000000000000111111111111111000001111100000000000000000000000000000000000011110001111100000011111111111111110000011100000000000000011111111111111110000011111111111110000001111111111111111000000000000001111111111111110000001111100001111110000001111111111111111000000000000000000000000000000000011110000011111111111111100000011111111111111100001111111111111111000000000000001111110001111000011111111111100000000000000001111111111111100000011111111111111100000000000000110000011111111111111100000111111111111111100000111110000000000000001111110000111110000111111000000000000000000000000000000000011111111111111110001111111111111111000001111111111111111000000000000000111100000111110000111100000111111111111111000000000000000111111000000000000000111000000111111111111111000111100000000000000000000000000000000000011111111111111100000000000000011111110000111100000111111000001111110000000000000001111110000000000000000000000000000000000000111111000111111111111111100000111100000011111110000000000000011110000111111111111111000000000000011111111111111000001111111111111111000001111100001111100000000000000011111111111111000001111110000011111111111111111000011111111111111100000000000000000000000000000000000001111111111111111000001111110000011110000000000000111111111111111000001111111111111111000011111111111111110000000000000001111111111111100000011111111111111100000111100000000000000011111100000111111111111110000001110000011111111111111110000011111000011111111111111' => 'SOS! THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG.',
  '00000000000111111100000011010001110111000000001110000000000000000001111111011111100001101111100000111100111100011111100000001011100000011111110010001111100110000011111100101111100000000000000111111100001111010110000011000111110010000011111110001111110011111110000010001111110001111111100000001111111101110000000000000010110000111111110111100000111110111110011111110000000011111001011011111000000000000111011111011111011111000000010001001111100000111110111111110000001110011111100011111010000001100001001000000000000000000111111110011111011111100000010001001000011111000000100000000101111101000000000000011111100000011110100001001100000000001110000000000000001101111101111000100000100001111111110000000001111110011111100011101100000111111000011011111000111111000000000000000001111110000100110000011111101111111011111111100000001111110001111100001000000000000000000000000000000000000000000000000000000000000' => 'THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG',
  '00000000000000011111111000000011111111111100000000000111111111000001111111110100000000111111111111011000011111111011111111111000000000000000000011111111110000110001111111111111000111000000000001111111111110000111111111100001100111111111110000000000111111111111011100001110000000000000000001111111111010111111110110000000000000001111111111100001111111111110000100001111111111111100000000000111111111000000011000000111000000000000000000000000000011110001111100000111100000000111111111100111111111100111111111111100000000011110011111011111110000000000000000000000111111111110000000011111000000011111000000001111111111110000000001111100011111111000000000111111111110000011000000000111110000000111000000000011111111111111000111001111111111001111110000000000000000000001111000111111111100001111111111111100100000000001111111100111111110111111110000000011101111111000111000000001001111111000000001111111111000000000111100001111111000000000000011111111100111111110111111111100000000000111111110000001100000000000000000000111111101010000010000001111111100000000011111000111111111000000111111111110011111111001111111110000000011000111111110000111011111111111100001111100001111111100000000000011110011101110001000111111110000000001111000011111110010110001111111111000000000000000000111111111110000000100000000000000000011110111110000001000011101110000000000011111111100000011111111111100111111111111000111111111000001111111100000000000001110111111111111000000110011111111111101110001111111111100000000111100000111100000111111111100000111111111111000000011111111000000000001000000111100000001000001111100111111111110000000000000000000010001111111100000011111111100000000000000100001111111111110111001111111111100000111111100001111111111000000000000000000000000011100000111111111111011110000000010000000011111111100011111111111100001110000111111111111100000000000000111110000011111001111111100000000000011100011100000000000011111000001111111111101000000001110000000000000000000000000000111110010000000000111111111000011111111110000000000111111111111101111111111100000000010000000000000011111111100100001100000000000000111100111100000000001100000001111111111110000000011111111111000000000111100000000000000000000111101111111111111000000000001111000011111000011110000000001100111111100111000000000100111000000000000111110000010000011111000000000000001111111111100000000110111111111100000000000000111111111111100000111000000000111111110001111000000111111110111111000000001111000000000010000111111111000011110001111111110111110000111111111111000000000000000000000000111111111110000000111011111111100011111110000000001111111110000011111111100111111110000000001111111111100111111111110000000000110000000000000000001000011111111110000000001111111110000000000000000000000011111111111111000000111111111000001111111110000000000111111110000010000000011111111000011111001111111100000001110000000011110000000001011111111000011111011111111110011011111111111000000000000000000100011111111111101111111100000000000000001100000000000000000011110010111110000000011111111100000000001111100011111111111101100000000111110000011110000111111111111000000001111111111100001110111111111110111000000000011111111101111100011111111110000000000000000000000000010000111111111100000000001111111110111110000000000000000000000110000011110000000000001111111111100110001111111100000011100000000000111110000000011111111110000011111000001111000110000000011100000000000000111100001111111111100000111000000001111111111000000111111111100110000000001111000001111111100011100001111111110000010011111111110000000000000000000111100000011111000001111000000000111111001110000000011111111000100000000000011111111000011001111111100000000000110111000000000000111111111111000100000000111111111110000001111111111011100000000000000000000000000' => 'MGY CQD CQD SOS TITANIC POSITION 41.44 N 50.24 W. REQUIRE IMMEDIATE ASSISTANCE. COME AT ONCE. WE STRUCK AN ICEBERG. SINKING'
}

def decode_bits_advanced(bits)
  return LOOKUP[bits] if LOOKUP[bits]

  bits.sub!(/^0*/, '').sub!(/0*$/, '')
  
  return '' if bits.empty?
  
  lengths = bits.split(/(0+)/).map(&:length).sort.uniq
  
  word_split_length   = 7
  letter_split_length = 4
  dash_length         = 4
  
  bits.split(/0{#{word_split_length},}/).map { |word| word.split(/0{#{letter_split_length},}/).map { |letter| letter.split(/0+/).map { |blip| blip.length >= dash_length ? '-' : '.' }.join } }
end

def decode_morse(morse_code)
  return morse_code if morse_code.is_a?(String)

  morse_code.map { |word| word.map { |letter| MORSE_CODE[letter] }.join }.join(' ')
end
