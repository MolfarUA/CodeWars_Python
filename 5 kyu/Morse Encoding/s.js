536602df5d0266e7b0000d31


var Morse = {}

Morse.encode = function(message) {
  var ints = []
  var bits = message.split('').map(function(c) {
    return Morse.alpha[c]
  }).join('000')
  
  for (var i = 32 - (bits.length % 32); i--;) {
    bits += '0'
  }

  for (var i = 0; i < bits.length; i += 32) {
    ints.push(parseInt(bits.substr(i, 32), 2) | 0)
  }
  
  return ints
}

Morse.decode = function(ints) {
  var bits = ints.map(function(i) {
    return ('00000000000000000000000000000000' + (i >>> 0).toString(2)).slice(-32)
  }).join('')

  return bits.replace(/0+$/, '').split('0000000').map(function(word) {
    return word.split('000').map(function(c) {
      return Morse.bits[c]
    }).join('')
  }).join(' ')
}

Morse.alpha = {
  'A': '10111',
  'B': '111010101',
  'C': '11101011101',
  'D': '1110101',
  'E': '1',
  'F': '101011101',
  'G': '111011101',
  'H': '1010101',
  'I': '101',
  'J': '1011101110111',
  'K': '111010111',
  'L': '101110101',
  'M': '1110111',
  'N': '11101',
  'O': '11101110111',
  'P': '10111011101',
  'Q': '1110111010111',
  'R': '1011101',
  'S': '10101',
  'T': '111',
  'U': '1010111',
  'V': '101010111',
  'W': '101110111',
  'X': '11101010111',
  'Y': '1110101110111',
  'Z': '11101110101',
  '0': '1110111011101110111',
  '1': '10111011101110111',
  '2': '101011101110111',
  '3': '1010101110111',
  '4': '10101010111',
  '5': '101010101',
  '6': '11101010101',
  '7': '1110111010101',
  '8': '111011101110101',
  '9': '11101110111011101',
  '.': '10111010111010111',
  ',': '1110111010101110111',
  '?': '101011101110101',
  "'": '1011101110111011101',
  '!': '1110101110101110111',
  '/': '1110101011101',
  '(': '111010111011101',
  ')': '1110101110111010111',
  '&': '10111010101',
  ':': '11101110111010101',
  ';': '11101011101011101',
  '=': '1110101010111',
  '+': '1011101011101',
  '-': '111010101010111',
  '_': '10101110111010111',
  '"': '101110101011101',
  '$': '10101011101010111',
  '@': '10111011101011101',
  ' ': '0',
}

Morse.bits = {}

for (var x in Morse.alpha) {
  Morse.bits[Morse.alpha[x]] = x
}
________________________________________________
const Morse = {
  encode: message => {
    let bin = [...message]           // message to character array
      .map(c => Morse.alpha[c])      // Map charactes
      .join('000');                  // Join with character separator
      
    return (bin + Morse.pad(bin))    // Pad end with missing "0"
      .match(/.{32}/g)               // Split up in sections of 32 characters
      .map(s => parseInt(s, 2) | 0); // Parse each character to int, and cast it to signed.
  },
  
  decode: integerArray => 
    integerArray
      .map(i => (i>>>0).toString(2))      // Convert each int to bin
      .map(s => Morse.pad(s) + s)         // Pad the start of each binary string
      .join('')                           // Join the results into a single string
      .replace(/0+$/, '')                 // Trim trailing "0"s
      .replace(/0{7}/g, '000000')         // Spaces would split into:         [...", "", "0...]
      .split('000')                       // Split characters. Spaces become: [...", "", "...]
      .map(b => Morse.alphaInv[b || '0']) // Map the resulting binary string back to characters.
      .join(''),                          // Char array to string.
      
  pad: s => s.length % 32 ? '0'.repeat(32 - s.length % 32) : '',
  
  alpha: {'A': '10111','B': '111010101','C': '11101011101','D': '1110101','E': '1','F': '101011101','G': '111011101','H': '1010101','I': '101','J': '1011101110111','K': '111010111','L': '101110101','M': '1110111','N': '11101','O': '11101110111','P': '10111011101','Q': '1110111010111','R': '1011101','S': '10101','T': '111','U': '1010111','V': '101010111','W': '101110111','X': '11101010111','Y': '1110101110111','Z': '11101110101','0': '1110111011101110111','1': '10111011101110111','2': '101011101110111','3': '1010101110111','4': '10101010111','5': '101010101','6': '11101010101','7': '1110111010101','8': '111011101110101','9': '11101110111011101','.': '10111010111010111',',': '1110111010101110111','?': '101011101110101',"'": '1011101110111011101','!': '1110101110101110111','/': '1110101011101','(': '111010111011101',')': '1110101110111010111','&': '10111010101',':': '11101110111010101',';': '11101011101011101','=': '1110101010111','+': '1011101011101','-': '111010101010111','_': '10101110111010111','"': '101110101011101','$': '10101011101010111','@': '10111011101011101',' ': '0'},
  alphaInv: {}
};

for(const key in Morse.alpha){
  Morse.alphaInv[Morse.alpha[key]] = key;
}
________________________________________________
const PADDING = "00000000000000000000000000000000";

var Morse = {};

Morse.encode = function(message){
  return (message.split('')
          //map to Morse bits
          .map(x =>  Morse.alpha[x] + '000' ).join('') + '0000000')
          //split into 4 bytes strings
          .match(/[01]{1,32}/gi)
          //convert to Int32
          .map(x => parseInt(x,2) << (32 - x.length));
};

Morse.decode = function(arr){
  return arr //convert to uInt32
            .map( x => (x >>> 0).toString(2))
            // pad 0's to 32 bits
            .map(x => (PADDING + x).substr(-32) ).join('')
            //split on char delimeters
            .replace(/(000)(.)/gi,' $2').split(' ')
            // inverse mapping 
            .map( x => Morse.bitsToAlpha(x) )
            //remove trailing 0's / spaces
            .join('').trim();
};

Morse.bitsToAlpha = function(code) {
 for (let k in Morse.alpha ) { 
    if(code === Morse.alpha[k]) {
      return k;
    }
  }
  return "";
}

Morse.alpha = {
  'A': '10111',
  'B': '111010101',
  'C': '11101011101',
  'D': '1110101',
  'E': '1',
  'F': '101011101',
  'G': '111011101',
  'H': '1010101',
  'I': '101',
  'J': '1011101110111',
  'K': '111010111',
  'L': '101110101',
  'M': '1110111',
  'N': '11101',
  'O': '11101110111',
  'P': '10111011101',
  'Q': '1110111010111',
  'R': '1011101',
  'S': '10101',
  'T': '111',
  'U': '1010111',
  'V': '101010111',
  'W': '101110111',
  'X': '11101010111',
  'Y': '1110101110111',
  'Z': '11101110101',
  '0': '1110111011101110111',
  '1': '10111011101110111',
  '2': '101011101110111',
  '3': '1010101110111',
  '4': '10101010111',
  '5': '101010101',
  '6': '11101010101',
  '7': '1110111010101',
  '8': '111011101110101',
  '9': '11101110111011101',
  '.': '10111010111010111',
  ',': '1110111010101110111',
  '?': '101011101110101',
  "'": '1011101110111011101',
  '!': '1110101110101110111',
  '/': '1110101011101',
  '(': '111010111011101',
  ')': '1110101110111010111',
  '&': '10111010101',
  ':': '11101110111010101',
  ';': '11101011101011101',
  '=': '1110101010111',
  '+': '1011101011101',
  '-': '111010101010111',
  '_': '10101110111010111',
  '"': '101110101011101',
  '$': '10101011101010111',
  '@': '10111011101011101',
  ' ': '0' // Technically is 7 0-bits, but we assume that a space will always be between two other characters
};
