from time import perf_counter as _timer


def do_tests(puzzles, desc):
        test.describe(desc)

        t0 = _timer()
        for i, puzzle in enumerate(puzzles, 1):
            args, solution, it = puzzle
            test.it('Test {}: {}'.format(i, it))
            st0 = _timer()
            test.assert_equals(solve(*args), solution)
            st1 = _timer()
            print('<COMPLETEDIN::> {:.3f}'.format((st1 - st0) * 1000))
        t1 = _timer()

        print('<COMPLETEDIN::> {:.3f}'.format((t1 - t0) * 1000))


def rand_tests():
    from itertools import groupby
    from random import randint, shuffle, choice
    import numpy as np

    def mix_up(puzzles):
        solutions = []
        for puzzle in puzzles:
            rows = puzzle.split(';')
            p_sol = []
            for row in rows:
                z, row = int(row[0]), row[1:]
                row_sol = []
                for i, g in enumerate(row.split(':')):
                    row_sol += [z ^ (i % 2)] * int(g)
                p_sol.append(row_sol)
            solutions.append(p_sol)
            
        foobar = lambda foo: foo
        
        ans = [tuple(map(tuple, [foobar, np.fliplr, np.flipud][randint(0, 2)](np.rot90(sol, randint(0, 3)))))
               for sol in solutions]
        h_clues = [tuple(tuple(map(len, [list(g) for k, g in groupby(row) if k]))
                         for row in np.rot90(sol[::-1], -1)) for sol in ans]
        v_clues = [tuple(tuple(map(len, [list(g) for k, g in groupby(row) if k]))
                         for row in sol) for sol in ans]
        args = [((h_c, v_c), len(h_c), len(v_c)) for h_c, v_c in zip(h_clues, v_clues)]
        its = ['{} x {}'.format(ag[1], ag[2]) for ag in args]
        
        questions = list(zip(args, ans, its))
        shuffle(questions)
        
        return questions
    
    def small_puzzles():
        p1 = '17:6:3:1:3:1:1:1:2;17:12:2:2:2;01:8:2:1:2:1:3:1:1:5;14:1:3:3:1:1:1:5:6;11:1:1:3:' \
            + '3:2:1:1:1:5:6;14:4:1:4:2:1:8:1;11:1:2:4:1:6:6:1:1:2;14:2:3:1:1:4:6:3:1;14:4:1:2:' \
            + '2:4:2:5:1;14:1:3:1:4:1:6:1:1:1:1:1;17:1:7:1:1:2:3:1:1:1;03:3:2:3:1:6:3:3:1;01:5:' \
            + '3:3:3:3:3:2:2;09:2:5:3:1:1:4;03:2:5:1:1:1:2:1:1:2:6;03:2:1:1:1:5:3:2:7;05:13:2:1' \
            + ':4;05:11:4:2:2:1;11:4:6:1:4:4:2:2:1;13:3:5:1:3:3:1:1:2:3;12:1:1:1:2:2:5:3:5:3;02' \
            + ':5:4:3:1:6:4;01:1:1:3:4:4:3:1:6:1;01:1:1:3:4:6:2:1:3:3;12:1:2:5:6:1:3:1:4'
        
        p2 = '14:2:3:6:6:1:3;12:3:6:2:2:1:5:1:3;12:4:2:5:5:2:1:3:1;11:5:1:3:1:3:3:3:2:3;06:3:1' \
            + ':1:1:3:5:4:1;01:2:2:7:1:1:6:4:1;13:1:3:1:2:1:6:3:3:2;01:1:3:1:4:1:1:3:4:3:3;11:4' \
            + ':1:3:1:1:3:1:3:7;04:3:1:1:1:3:4:1:1:1:5;04:5:1:1:1:1:2:3:5:2;05:1:3:3:1:1:1:4:5:' \
            + '1;02:1:2:1:1:11:3:4;02:2:1:1:2:2:1:8:2:4;01:2:1:1:4:1:1:9:1:4;02:2:7:9:1:4;14:3:' \
            + '1:1:3:1:5:1:6;14:6:15;12:8:2:1:2:1:1:1:1:2:4;03:4:7:2:5:2:2;02:7:1:1:4:1:6:3;01:' \
            + '2:1:4:4:2:1:3:2:5;04:2:7:4:2:2:1:3;12:2:3:4:1:1:5:1:6;17:1:4:3:9:1'
        
        p3 = '02:3:4:3;01:2:4:3:2;14:1:4:3;19:3;01:3:1:3:4'
        
        p4 = '01:1:4;12:4;12:2:1:1;01:2:2:1;01:3:1:1;01:4:1;11:1:3:1'
        
        p5 = '01:1:1:3:1;02:1:1:1:2;02:1:1:1:2;01:5:1;12:1:4;17;17;01:5:1'
        
        p6 = '02:1:5:1:2;03:1:3:1:3;02:7:2;01:2:1:3:1:2:1;111;11:1:7:1:1;11:1:1:5:1:1:1;03:2:1' \
            + ':2:3'
        
        p8 = '11:3:3:5:3:9:1;04:2:2:2:2:3:8:2;02:7:1:1:1:5:6:2;02:3:1:1:1:6:3:8;02:13:3:6:1;11' \
            + '4:4:2:2:1:2;18:1:3:1:2:3:3:4;01:14:2:2:4:1:1;11:1:10:1:3:2:2:5;16:1:5:2:3:8;03:1' \
            + '0:2:1:2:3:4;07:6:5:5:2;110:1:4:1:1:1:3:1:1:2;19:3:3:2:2:1:1:1:3;110:3:2:1:1:1:3:' \
            + '1:1:2;01:3:1:1:2:2:6:4:1:1:1:2;03:2:5:1:4:1:2:2:1:2:1:1;11:5:1:1:1:4:6:1:2:1:2;1' \
            + '1:1:7:1:11:3:1;18:3:10:4;11:1:4:1:1:3:1:2:7:4;03:3:1:1:2:4:1:1:1:1:2:3:2;03:12:1' \
            + ':1:6:2;02:3:3:7:6:4;15:3:3:1:3:6:4'
        
        p9 = '11:6:1:1:1:5:4:3:3;11:5:6:1:1:1:3:1:1:2:1:1:1;14:2:3:2:8:5:1;15:2:9:2:4:3;11:1:1' \
            + ':5:8:2:5:2;11:1:1:3:1:1:9:1:3:1:3;02:1:5:2:1:2:1:4:2:4:1;01:4:2:1:2:1:1:5:1:1:3:' \
            + '2:1;15:6:1:3:4:3:1:1:1;11:1:3:5:3:1:5:3:3;16:3:5:1:3:4:3;13:1:3:2:9:3:3:1;11:1:5' \
            + ':3:2:3:1:1:1:1:1:1:2:1:1;04:1:1:1:3:3:1:9:2;04:3:2:13:1:1:1;05:3:2:1:1:3:3:5:2;1' \
            + '2:4:8:7:2:2;12:6:3:1:3:5:3:2;01:5:1:3:2:4:3:3:3;01:5:2:1:4:4:1:3:1:1:2;02:1:1:2:' \
            + '7:1:1:2:1:1:2:2:2;11:1:4:10:1:1:2:3:1:1;11:1:6:2:1:7:1:1:5;17:1:4:1:1:5:6;14:1:2' \
            + ':1:3:2:3:3:5:1'
        
        p10 = '07:4:1:7:4:1:1;07:3:2:8:5;12:2:5:2:9:1:1:1:2;11:3:3:1:1:1:5:2:7:1;06:11:2:5:1;07' \
            + ':3:1:1:1:4:1:4:3;12:1:1:4:8:1:1:1:1:5;16:2:3:4:2:1:1:6;18:2:2:1:7:5;12:1:1:1:10:' \
            + '2:3:5;04:2:1:2:3:1:1:1:1:3:1:1:4;12:3:1:1:4:1:2:1:6:1:1:2;01:5:3:2:1:2:2:7:2;17:' \
            + '2:6:1:1:1:4:3;110:1:1:2:2:1:1:1:3:3;12:1:7:1:2:1:1:1:5:4;01:1:1:2:1:9:1:3:6;13:1' \
            + ':1:2:7:1:5:1:1:3;01:3:2:7:1:6:5;11:3:7:1:3:1:2:3:2:2;04:6:2:3:1:1:3:5;03:6:1:4:4' \
            + ':3:1:1:2;02:4:1:1:4:2:7:1:1:2;02:3:3:1:3:1:8:3:1;01:6:4:4:1:1:4:1:1:1:1'
        
        p11 = '14:1:4:4:4:1:7;18:5:1:1:5:2:3;13:4:2:7:1:6:2;11:1:2:1:1:1:4:3:2:9;11:1:1:4:3:5:3' \
            + ':5:1:1;11:6:13:3:2;01:2:1:1:1:5:3:3:1:1:3:3;02:2:1:7:1:7:3:2;01:9:1:1:2:4:1:1:2:' \
            + '3;03:2:1:3:2:2:2:5:2:3;04:1:1:3:3:1:2:4:2:1:1:2;02:1:1:3:6:7:1:1:1:2;12:2:3:1:1:' \
            + '3:8:5;13:1:1:1:1:5:8:1:1:1:1:1;11:3:1:1:2:3:13:1;12:1:12:3:6:1;12:2:11:4:3:3;12:' \
            + '3:10:3:4:2:1;13:1:11:10;11:1:1:2:2:1:5:1:5:6;04:3:1:1:1:3:1:4:2:1:1:2:1;04:3:4:1' \
            + ':2:4:1:6;03:4:3:1:2:3:4:5;14:2:1:4:1:2:1:1:1:3:5;13:7:3:8:4'
        
        p12 = '11:2:8:2:12;11:2:13:1:8;03:1:3:6:3:1:1:7;14:5:4:5:4:1:2;13:7:1:1:1:4:5:1:2;12:7:' \
            + '1:2:2:5:3:1:2;13:7:3:6:3:1:2;12:3:1:3:7:1:2:1:1:1:3;13:7:5:6:4;15:3:1:1:8:3:1:3;' \
            + '15:1:6:1:4:4:1:1:1:1;18:2:3:2:1:5:4;114:5:1:2:3;111:12:2;12:2:1:2:3:15;12:2:1:1:' \
            + '5:9:2:2:1;11:2:2:1:1:1:3:8:4:2;01:4:1:4:7:7:1;03:2:3:1:4:1:3:4:4;02:6:9:2:6;02:6' \
            + ':7:3:1:1:5;01:8:1:1:4:4:6;01:12:3:5:2:2;01:1:2:6:1:3:7:4;01:1:1:7:1:3:7:4'
        
        p13 = '12:1:1:6:2:4:1:3:5;02:1:1:1:5:3:2:3:2:5;01:1:1:1:6:7:4:4;12:1:2:4:4:1:4:1:3:1:1:' \
            + '1;03:3:4:1:1:1:1:3:3:3:2;04:1:4:1:1:1:2:1:1:7:2;04:1:2:2:3:1:3:6:3;11:5:5:1:2:3:' \
            + '5:1:2;06:4:1:8:1:1:1:1:2;06:9:3:1:1:2:3;13:1:11:2:1:7;111:1:2:2:4:1:1:1:1:1;14:4' \
            + ':4:3:1:1:4:1:1:2;14:3:4:1:5:1:1:1:1:4;12:6:2:2:1:1:1:2:2:6;15:6:1:1:2:2:1:7;16:5' \
            + ':2:1:4:7;17:4:2:2:1:8:1;02:1:1:3:3:4:1:1:6:3;04:2:1:2:2:2:1:2:4:5;11:1:5:1:1:3:1' \
            + ':7:4:1;110:2:2:6:3:2;111:8:6;110:12:3;111:12:2'
        
        p14 = '11:4:1:1:3:2:12:1;05:6:3:3:3:3:2;04:4:1:2:2:6:3:3;05:2:2:3:1:1:1:4:1:1:1:3;12:2:' \
            + '2:3:4:3:3:3:1:1:1;13:1:3:4:1:1:1:2:3:3:3;13:1:1:2:1:3:1:2:5:4:2;13:3:1:4:1:1:7:3' \
            + ':2;13:2:1:1:1:2:2:2:6:4:1;15:5:1:5:2:5:1:1;112:13;07:5:7:1:3:2;01:1:2:2:1:1:1:4:' \
            + '3:4:2:3;12:6:5:1:2:1:4:1:1:1:1;01:2:3:2:3:5:1:1:2:5;13:3:2:4:3:2:3:3:2;12:4:4:2:' \
            + '2:1:5:2:3;01:1:1:1:1:4:2:2:2:10;04:9:2:3:2:5;11:3:4:4:1:3:9;12:3:3:2:2:2:1:1:3:2' \
            + ':1:2:1;12:2:2:7:2:2:3:2:3;04:3:3:1:1:1:3:3:1:4:1;03:5:2:4:1:4:1:1:1:3;02:6:3:3:1' \
            + ':2:1:2:4:1'
        
        p15 = '03:3:2:1:2:3:3:1:3:3:1;02:2:1:1:2:7:2:1:1:1:2:2:1;11:5:2:4:1:3:2:1:3:3;11:1:1:6:' \
            + '2:8:1:1:2:2;014:2:2:2:2:1:2;08:1:1:1:1:3:1:3:2:3:1;02:1:5:1:2:1:2:6:1:4;05:2:1:1' \
            + ':1:2:1:3:1:8;09:1:2:1:1:11;11:1:1:2:2:1:1:1:7:1:2:3:1:1;11:1:1:3:3:2:1:1:1:1:2:1' \
            + ':3:3:1;12:6:5:1:6:3:2;13:5:1:1:4:1:3:5:2;13:3:1:1:1:1:1:3:2:1:2:3:3;11:4:1:2:6:1' \
            + ':1:1:2:1:1:1:3;01:1:1:1:1:2:1:5:4:8;12:4:2:2:4:1:1:2:6:1;01:1:3:3:1:1:1:4:1:8:1;' \
            + '11:1:15:3:2:3;03:9:2:4:3:2:2;01:10:5:3:6;12:1:2:1:2:5:5:1:1:5;12:2:5:3:7:6;11:4:' \
            + '1:1:2:2:4:1:1:3:2:3;11:5:2:1:8:3:2:3'
        
        p16 = '15:1:1:1:1:1:6:1:3:2:3;12:1:4:5:3:1:1:5:3;12:2:6:2:2:2:1:3:2:3;04:9:1:1:5:3:2;04' \
            + ':11:5:2:1:2;16:3:6:5:5;02:3:3:3:1:6:1:6;01:5:1:2:6:2:2:3:1:2;02:3:1:4:6:2:2:3:2;' \
            + '01:7:3:1:1:3:4:2:1:1:1;03:4:1:1:4:3:4:5;03:3:6:3:4:6;12:2:3:3:4:1:1:2:4:2:1;12:3' \
            + ':2:5:1:1:1:2:6:1:1;05:3:1:4:2:1:1:4:1:3;01:1:5:1:2:1:3:1:1:4:2:3;01:1:3:7:5:3:2:' \
            + '3;11:1:2:1:1:1:3:1:1:3:5:2:1:1:1;12:1:5:4:8:3:2;03:5:1:1:2:8:1:4;02:7:1:6:2:3:2:' \
            + '2;02:3:1:2:4:5:3:1:1:2:1;02:1:2:1:1:2:5:4:2:1:1:2:1;04:2:8:7:1:3;04:2:1:2:1:2:3:' \
            + '6:1:1:2'
        
        p17 = '01:6:2:2:1:2:3:8;01:4:3:3:7:1:1:5;01:4:1:2:1:1:1:1:1:1:3:8;02:2:3:3:7:2:1:1:1:3;' \
            + '03:1:1:6:3:1:1:9;01:1:3:6:3:1:1:5:1:3;12:3:4:3:1:1:2:2:5:1:1;12:1:4:6:4:1:3:2:2;' \
            + '16:3:2:1:2:3:2:1:5;17:2:1:2:3:1:3:3:1:2;01:1:1:1:1:1:2:1:2:5:1:3:1:2:2;06:9:3:1:' \
            + '3:1:2;07:1:2:5:1:9;11:4:4:2:2:2:1:2:1:1:1:2:2;01:3:1:4:1:2:2:2:4:5;01:1:1:2:1:3:' \
            + '1:1:2:4:3:3:2;01:1:1:1:4:2:3:2:1:7:1:1;15:2:3:1:1:1:1:1:3:4:3;01:1:1:1:4:2:1:1:4' \
            + ':2:4:3;01:3:2:3:3:3:7:3;14:3:1:5:3:5:4;12:1:9:1:3:5:4;01:3:3:4:1:2:8:1:1:1;111:1' \
            + ':3:1:3:3:1:2;110:3:3:9'
        
        p18 = '05:3:7;04:1:2:2:6;03:1:1:1:2:5:2;02:3:7:3;04:2:1:1:2:2:2:1;01:1:3:1:1:2:2:1:1:1:' \
            + '1;11:1:1:3:1:1:3:2:1:1;01:1:2:1:1:2:4:2:1;01:2:1:2:1:6:2;12:1:2:3:1:2:1:2:1;01:3' \
            + ':1:1:1:2:1:2:1:2'
        
        p19 = '02:5:7;01:6:7;01:3:1:1:8;01:5:8;01:3:1:1:8;01:6:3:3:1;01:3:2:1:2:2:2:1;01:10:2:1' \
            + ';112:1:1;114;14:2:8;14:3:6:1'
        
        p20 = '12:3;13:1:1;01:3:1;02:1:1:1;02:2:1'
        
        p21 = '13:2;02:1:1:1;02:2:1;02:3;12:1:1:1'
        
        p22 = '11:1:1:1:1;12:3;13:2;01:2:2;01:3:1'
        
        p23 = '11:1:1:1:1;13:1:1;01:4;11:4;11:4'
        
        p24 = '03:1:1;02:3;13:2;13:1:1;11:3:1'
        
        p25 = '14:1;13:2;11:3:1;04:1;11:2:2'
        
        p28 = '11:2:3:1:4:1:3;11:1:9:1:3;02:3:1:7:2;01:6:3:1:2:2;19:3:1:1:1;11:1:3:1:3:3:3;11:2' \
            + ':2:3:1:6;15:1:4:3:1:1;13:2:5:1:4;14:1:3:3:4;01:1:4:3:1:5;01:6:2:4:2;13:1:2:1:3:1' \
            + ':1:3;16:2:4:3;15:2:5:3'
        
        p30 = '01:6;11:1:2:1:1:1;02:5;01:6'
        
        p31 = '12:1:4;13:2:2;11:1:1:1:1:1:1;11:1:2:1:2;06:1'
        
        p32 = '01:6:8;12:4:5:4;11:1:4:4:5;11:4:5:4:1;15:4:4:1:1;11:3:5:3:1:1:1;11:7:3:1:1:1:1;1' \
            + '1:2:2:1:2:2:1:1:1:1:1;11:2:1:3:1:2:1:1:1:1:1;11:3:1:2:1:2:1:1:1:1:1;11:2:2:2:1:2' \
            + ':1:1:1:1:1;11:9:1:1:1:1:1;14:6:1:1:2:1;03:4:3:2:3;06:4:5'
        
        p33 = '015;03:8:4;02:2:2:1:3:2:3;01:2:8:2:2;01:1:2:1:3:1:3:1:2;01:1:10:1:2;01:1:1:8:1:1' \
            + ':2;01:2:8:2:2;12:10:2:1;11:3:1:3:1:4:1:1;11:12:1:1;12:10:2:1;01:12:2;05:4:6;05:1' \
            + ':2:1:6'
        
        p34 = '02:1:12;02:1:5:1:6;02:1:4:3:5;02:1:4:3:5;01:3:3:3:5;02:1:5:1:3:3;02:3:1:5:1:3;02' \
            + ':1:1:11;07:3:2:3;08:1:4:1:1;07:3:5;06:5:4;06:2:1:2:4;06:1:3:1:4;04:3:3:3:2'
        
        p35 = '05:5:5;04:7:4;03:9:3;12:1:2:1:3:1:2:1:2;14:3:1:3:4;11:1:2:1:2:1:2:1:2:1:1;11:1:2' \
            + ':1:2:1:2:1:2:1:1;15:5:5;01:3:2:2:3:3:1;02:1:3:2:4:1:2;02:2:1:1:2:1:2:2:2;12:1:1:' \
            + '2:2:3:1:1:2;11:2:2:5:2:2:1;01:1:2:2:3:2:3:1;12:3:5:4:1'
        
        p36 = '12:3:2:2:4:2;11:1:3:1:1:1:2:2:2:1;01:1:3:1:2:1:4:2;11:1:1:1:1:1:1:1:1:1:2:2:1;11' \
            + ':5:1:1:1:1:1:2:2;11:1:3:1:1:1:1:2:3:1;01:1:1:1:1:1:1:3:2:1:2;02:3:4:2:1:2:1;01:2' \
            + ':1:1:2:1:2:1:2:1:1;01:1:1:2:1:1:1:1:1:4:1;02:2:1:3:2:1:1:1:2;12:1:2:1:2:3:1:1:2;' \
            + '11:4:4:1:2:2:1;01:1:2:1:4:2:3:1;12:2:6:4:1'
        
        p37 = '04:4:7;03:8:4;01:3:3:5:3;14:3:1:2:2:3;12:1:2:1:2:2:2:3;12:2:4:1:2:4;01:3:1:2:1:4' \
            + ':3;03:2:1:6:3;04:3:1:3:2:2;07:1:4:3;08:1:1:5;02:5:1:1:1:4:1;02:9:4;03:4:1:1:6;08' \
            + ':1:6'
        
        p38 = '02:2:8:2:1;02:1:1:2:6:1:1:1;01:1:1:1:1:1:4:2:1:1:1;01:2:1:1:4:1:1:2:1:1;03:3:1:2' \
            + ':1:1:1:2:1;01:2:2:3:1:1:1:2:2;11:1:1:1:1:2:1:1:3:1:1:1;01:1:1:2:1:2:2:1:1:1:1:1;' \
            + '11:1:2:1:5:1:1:1:2;12:4:1:1:1:3:2:1;06:1:1:1:6;05:2:1:2:5;05:1:3:1:5;05:1:3:1:5;' \
            + '05:1:3:1:5'
        
        p39 = '12:4:2:7;11:1:2:2:1:1:2:5;11:1:1:1:1:2:1:1:1:2:2:1;11:1:1:1:1:1:2:1:1:1:1:1:1:1;' \
            + '11:1:1:1:1:5:1:2:2;11:3:1:1:1:1:1:1:1:1:1:1:1;11:2:2:1:4:1:1:2:1;12:2:4:1:1:3:1:' \
            + '1;02:3:2:2:1:3:2;01:3:4:2:5;11:1:1:6:3:3;01:2:6:1:2:1:2;12:1:1:4:3:4;11:2:6:2:1:' \
            + '3;02:1:6:1:5'

        puzzles = [p1, p2, p3, p4, p5, p6, p8, p9, p10,
                   p11, p12, p13, p14, p15, p16, p17, p18, p19, p20,
                   p21, p22, p23, p24, p25, p28, p30,
                   p31, p32, p33, p34, p35, p36, p37, p38, p39]
        return puzzles
    
    def med_puzzles():
    
        p1 = '04:9:22;04:9:2:8:12;04:9:2:8:12;04:9:2:8:12;04:9:2:8:12;04:9:2:8:12;04:9:22;06:5' \
            + ':24;06:5:3:14:7;06:5:3:14:7;06:5:3:14:7;014:14:7;014:14:7;014:14:7;06:8:21;08:2:' \
            + '25;08:5:16:4:2;08:13:2:2:4:4:2;09:12:14;09:5:2:5:1:2:5:3:3;06:7:7:1:1:2:5:3:3;04' \
            + ':9:1:3:3:1:8:3:3;04:6:3:4:3:1:8:4:2;04:7:2:5:2:1:10:2:2;04:7:2:10:2:1:5:4;04:7:2' \
            + ':2:1:12:3:4;01:14:1:12:7;01:14:1:4:4:4:2:1:4;01:14:1:4:4:4:2:1:4;01:14:1:15:4;01' \
            + ':14:1:7:3:9;02:4:6:15:1:7;012:4:3:8:1:7;07:3:9:8:8;07:3:25'
        
        p2 = '018:9:3;017:2:1:1:1:1:1:1:1:2:2;018:9:3;030;02:5:6:5:6:5:1;01:3:1:3:4:2:1:1:1:2:' \
            + '4:3:1:3;02:5:6:5:6:5:1;03:3:8:3:8:3:2;02:5:6:5:6:5:1;01:2:3:2:4:2:3:2:4:2:3:2;02' \
            + ':2:1:2:4:2:5:2:4:2:1:2:1;030;01:2:4:1:7:1:14;02:2:2:3:6:1:14;03:1:1:2:8:1:14;03:' \
            + '1:1:2:23;02:2:2:1:23;03:1:1:3:22;12:4:3:21;01:1:2:2:1:1:22;030;030;12:11:2:12:1:' \
            + '2;14:7:6:10:3;15:5:8:5:1:2:4;15:3:1:1:8:5:7;13:5:1:1:3:2:3:5:7;12:6:1:1:2:4:2:5:' \
            + '7;030;08:1:21;08:1:21;07:3:20;07:3:20;06:5:19;05:7:18'
        
        p3 = '125;11:23:1;11:14:3:6:1;11:12:6:5:1;11:10:8:5:1;11:9:9:5:1;11:8:3:1:6:5:1;11:7:3' \
            + ':4:4:5:1;11:6:1:2:4:2:2:6:1;11:1:2:4:2:3:2:1:2:6:1;12:1:2:4:1:1:1:3:2:7:1;12:2:1' \
            + ':4:1:1:1:1:1:1:1:8:1;11:1:3:3:4:1:1:1:1:5:4;11:3:2:2:2:1:4:5:1:2:2;11:4:2:2:1:3:' \
            + '2:3:3:1:1:1:1;11:5:8:3:2:2:2:1:1;11:6:6:2:3:6:1;11:6:9:8:1;11:6:7:10:1;11:6:7:10' \
            + ':1;11:7:5:11:1;11:7:4:12:1;11:6:5:12:1;11:6:6:11:1;11:5:7:11:1;11:5:7:11:1;11:5:' \
            + '7:11:1;11:5:7:11:1;11:5:7:11:1;11:6:5:12:1;11:6:5:12:1;11:7:3:13:1;11:7:2:14:1;1' \
            + '1:23:1;125'
        
        p4 = '11:2:2:4:3:2:4:3:2:2:2:1:4:2:1;11:3:1:3:3:1:2:3:2:3:1:2:1:1:3:1:2:1:1;12:1:5:1:1' \
            + '1:1:14;13:3:1:1:2:3:2:4:2:3:1:4:1:1:1:3;11:1:2:2:1:4:4:1:1:2:4:1:4:1:1:1:3:1;11:' \
            + '2:2:1:1:2:6:1:1:2:2:1:1:4:1:1:1:1:1:1:1:1;02:2:2:1:1:4:2:1:1:1:2:1:1:7:1:1:3:1:1' \
            + ';01:3:2:1:2:1:1:1:4:1:2:1:2:2:3:1:1:1:1:4;12:4:1:2:1:3:2:1:2:1:3:2:1:1:1:1:7;02:' \
            + '1:1:3:2:3:1:2:2:1:1:2:2:5:1:2:4;13:2:1:4:3:1:1:1:5:1:1:1:1:3:1:1:2:3;13:4:3:1:2:' \
            + '8:3:1:5:1:4;02:1:2:3:1:1:4:2:2:1:4:1:1:3:3:1:1:2;13:2:1:1:1:4:3:2:5:11:1:1;01:3:' \
            + '3:1:10:1:2:1:3:3:4:3;01:6:2:1:1:3:1:5:3:8:2:2;01:2:3:1:1:2:1:1:7:1:3:1:5:6;01:1:' \
            + '1:2:1:3:2:1:4:1:2:4:1:4:1:3:3;03:2:1:1:1:1:2:2:3:1:2:2:2:2:2:1:1:1:1:1:1:2;01:3:' \
            + '2:4:1:6:2:1:3:1:2:2:1:1:3:1:1;01:2:3:1:1:2:1:3:2:2:1:1:1:2:4:1:1:1:3:2;03:2:1:1:' \
            + '3:3:1:1:1:8:3:1:1:1:1:4;01:3:2:2:3:1:2:2:2:2:2:5:1:3:1:2:1;01:1:1:1:2:6:1:2:2:3:' \
            + '3:1:1:2:1:1:3:3;12:1:1:2:4:2:3:4:1:6:1:1:1:3:1:1:1;13:3:1:1:4:2:3:2:1:3:5:2:1:1:' \
            + '2:1;01:2:1:4:1:2:1:1:3:2:1:2:1:1:1:2:1:2:1:1:1:3;01:4:1:1:2:5:1:3:3:6:1:1:1:2:1:' \
            + '2;11:3:2:1:1:2:2:1:1:4:1:1:8:3:2:2;11:1:2:1:1:1:1:1:2:3:3:1:1:1:1:2:2:3:4:1:2'

        p5 = '02:3:6:11:2:6;02:1:1:1:5:13:2:5;02:1:1:2:4:13:3:4;01:2:2:2:2:7:1:1:1:5:3:3;01:1:' \
            + '1:1:2:1:2:5:5:5:4:2;01:2:3:1:2:4:1:2:1:2:1:4:5:1;02:2:1:3:2:3:7:3:7;04:5:2:1:2:5' \
            + ':2:1:8;04:6:1:2:1:5:1:4:6;05:6:1:2:5:2:2:1:6;11:5:19:5;11:6:6:6:1:1:1:2:1:5;11:7' \
            + ':7:5:5:5;11:8:16:5;12:8:6:3:8:3;12:9:5:3:10:1;12:9:6:1:4:1:7;12:9:11:2:6;12:10:1' \
            + '1:2:5;13:9:7:3:1:1:5:1;13:9:8:2:6:2;13:8:8:3:5:3;13:7:11:1:4:4;13:7:14:6;13:8:5:' \
            + '1:7:6;14:6:2:1:2:3:6:6;14:5:2:5:1:1:6:6;14:4:2:4:3:4:1:8;14:3:2:4:2:1:1:4:1:8;14' \
            + ':3:1:4:2:2:1:3:2:8'
        
        p6 = '035;03:11:21;03:13:10:6:3;03:13:10:6:3;03:13:10:6:3;03:13:10:6:3;03:13:1:8:1:6:3' \
            + ';03:13:1:8:1:6:3;03:6:2:5:1:8:10;03:6:2:1:7:8:8;03:9:7:12:4;03:9:7:12:4;03:9:7:5' \
            + ':2:5:4;03:5:11:5:2:5:4;03:5:11:2:1:2:2:5:4;03:5:11:2:1:3:1:5:4;03:5:20:3:4;01:13' \
            + ':14:3:4;01:13:14:3:4;01:13:3:6:3:5:4;01:8:3:2:3:6:1:1:10;01:8:3:2:3:6:12;03:6:3:' \
            + '2:3:6:12;03:6:3:2:3:18;017:18;013:2:7:13;010:5:7:13;010:5:7:13;010:5:1:1:5:13;01' \
            + '6:1:5:13;01:2:2:4:13:13;010:3:6:1:2:13;010:3:9:13;010:3:22;035'
        
        p7 = '031:3:1;06:4:21:3:1;04:1:26:3:1;04:1:11:12:3:3:1;04:2:10:12:3:3:1;02:4:2:7:2:6:2' \
            + ':3:3:3:1;02:4:2:7:2:6:2:3:3:3:1;02:4:2:7:2:11:3:3:1;02:4:2:2:2:3:2:11:7;02:22:2:' \
            + '2:7;02:16:2:4:2:8:1;02:13:1:3:1:14:1;06:1:1:4:4:3:1:14:1;06:1:1:4:4:3:1:15;06:1:' \
            + '1:4:1:6:1:15;06:6:1:6:1:8:3:4;06:6:1:2:1:3:1:8:3:4;06:6:1:2:1:3:16;17:4:8:3:4:9;' \
            + '17:4:8:3:4:9;17:4:8:3:4:2:1:6;115:7:4:1:1:7;08:2:2:3:6:2:4:1:2:1:4;08:2:2:3:6:2:' \
            + '4:1:2:1:4;03:2:3:2:3:2:2:2:2:2:4:1:2:1:1:1:2;03:2:3:2:3:2:2:2:3:1:4:4:1:1:2;03:2' \
            + ':3:4:1:2:2:2:3:7:1:2:3;08:4:1:2:2:2:3:7:1:2:3;05:2:1:4:1:2:2:2:3:4:4:2:3;05:2:1:' \
            + '7:2:2:3:4:4:2:3;017:2:3:2:1:2:1:2:4:1;017:2:3:7:6;011:5:6:7:1:3:2;08:2:1:5:14:3:' \
            + '2;08:2:7:2:16'
        
        p8 = '031:3:1;06:4:21:3:1;04:1:26:3:1;04:1:11:12:3:3:1;04:2:10:12:3:3:1;02:4:2:1:5:1:2' \
            + ':6:2:3:3:3:1;02:4:2:1:5:1:2:6:2:3:3:3:1;02:4:2:1:5:1:2:11:3:3:1;02:4:2:1:5:1:2:1' \
            + '1:7;02:7:5:7:5:2:7;02:16:2:1:5:8:1;02:13:1:3:1:1:4:9:1;06:1:1:4:4:3:1:1:4:9:1;06' \
            + ':1:1:4:4:3:1:1:4:10;06:1:1:4:1:6:1:1:6:8;06:6:1:6:1:1:6:1:3:4;06:6:1:2:1:3:1:2:5' \
            + ':2:2:4;06:6:1:2:1:3:16;17:4:21:3;17:4:21:3;13:3:1:4:11:6:4:3;13:3:9:3:4:6:4:3;08' \
            + ':2:2:3:3:4:6:4:3;02:20:6:4:3;02:15:5:11:2;02:3:2:10:5:11:2;02:15:5:10:3;02:4:2:1' \
            + '3:1:7:1:2:3;02:10:1:14:3:2:3;02:25:3:2:3;02:10:1:3:6:5:1:2:4:1;02:10:1:3:8:5:2:1' \
            + ':3;011:5:8:5:1:3:2;08:2:1:11:2:3:3:3:2;08:2:3:9:2:3:8'
            
        p9 = '031:3:1;06:4:21:3:1;02:32:1;02:32:1;02:32:1;02:5:8:19:1;02:5:8:4:1:5:1:8:1;02:5:' \
            + '8:1:6:3:1:8:1;02:5:8:1:6:9:4;05:2:8:1:6:9:4;05:2:8:1:6:12:1;05:2:8:8:5:6:1;02:5:' \
            + '8:8:5:6:1;02:21:5:7;02:21:5:7;02:21:5:7;02:33;06:6:2:1:1:3:16;17:4:21:3;17:4:21:' \
            + '3;13:3:1:4:12:5:4:3;13:3:9:1:1:1:4:6:4:3;08:2:2:3:1:19;122:3:10;113:6:3:3:10;12:' \
            + '7:4:6:3:3:10;12:7:4:6:7:6:3;12:7:2:1:1:6:7:6:3;12:7:4:6:7:6:3;12:7:9:4:4:6:3;09:' \
            + '3:1:1:8:4:6:3;02:10:1:1:8:4:6:3;011:3:5:3:2:11;08:2:1:3:5:3:2:11;08:2:3:1:5:3:1:' \
            + '12'
            
        p10 = '01:10:29;01:10:29;01:10:18:9:2;01:4:3:3:2:25:2;01:4:3:3:2:25:2;01:10:2:25:2;01:1' \
            + '0:10:2:6:9:2;02:4:15:2:6:9:2;02:2:1:1:4:4:7:2:10:4:3;02:2:1:1:4:4:7:2:10:4:3;02:' \
            + '4:4:4:7:2:10:4:3;010:19:4:5:2;05:24:7:2:2;05:10:13:12;05:5:3:2:13:12;05:5:3:2:13' \
            + ':4:5:3;05:10:13:4:5:3;05:10:3:4:6:4:5:3;018:4:6:4:5:3;018:4:6:12'
        
        p11 = '01:10:4;01:10:4;01:10:4;01:4:3:3:2:2;01:4:3:3:2:2;01:10:2:2;01:10:4;02:4:9;02:2:' \
            + '1:1:4:4:1;02:2:1:1:4:4:1;02:4:4:4:1;010:5;05:10;05:10;05:5:3:2;05:5:3:2;05:10;05' \
            + ':10;015;015;010:2:3;010:2:3;01:4:10;01:4:7:3;01:4:3:3:1:3;06:5:1:3;06:5:1:3;06:5' \
            + ':1:3;06:5:1:3;06:5:1:3;06:5:1:3;06:5:4;06:5:4;08:3:4;08:3:4;08:3:3:1;02:8:5;02:8' \
            + ':2:1:2;02:8:2:1:2;01:9:1:4;01:9:1:4;01:5:5:4;01:5:5:4;011:4;011:4'
        
        p12 = '023;03:3:17;03:3:7:10;03:3:7:10;01:11:1:10;01:22;01:1:3:2:3:8:1:4;01:1:3:2:5:6:1' \
            + ':4;01:1:3:2:5:3:8;01:6:5:3:8;01:16:6;01:16:6;08:9:6;01:16:1:5;01:8:4:4:1:5;01:8:' \
            + '4:4:1:5;01:8:4:4:1:5;01:14:3:5;01:5:3:6:3:5;01:5:3:3:11;01:5:4:2:3:4:4;07:5:3:4:' \
            + '4;07:5:3:4:4;07:12:4;013:6:4;01:6:6:6:4;01:3:2:1:8:5:3;01:9:5:5:3;01:7:1:1:5:5:3' \
            + ';07:1:1:1:13;06:11:6'
        
        p13 = '024;01:5:9:9;01:5:9:9;01:5:3:15;01:5:3:8:2:5;01:4:4:8:2:5;01:4:10:2:2:5;01:4:10:' \
            + '2:2:5;01:5:9:9;01:5:3:15;09:15;06:18;06:16:1:1;06:6:2:8:1:1;03:9:9:3;03:9:2:3:4:' \
            + '3;03:10:1:3:4:2:1;03:2:4:1:4:3:4:2:1;03:2:4:1:4:3:4:2:1;03:2:4:1:11:2:1;03:2:4:1' \
            + ':2:1:8:2:1;03:7:2:11:1;01:9:2:7:5;01:3:5:1:2:7:5;01:3:4:3:1:2:1:4:5;01:3:4:3:1:1' \
            + ':3:1:1:1:5;01:6:1:3:4:6:3;01:6:1:3:4:6:3;03:4:9:5:3'
        
        p14 = '023;02:2:10:8:1;02:2:10:8:1;02:2:1:8:1:8:1;01:3:1:8:1:8:1;01:3:1:4:1:3:1:3:2:3:1' \
            + ';01:3:1:8:1:3:2:3:1;01:3:1:3:1:4:1:3:2:3:1;05:3:1:13:1;05:8:1:8:1;06:4:4:8:1;06:' \
            + '2:1:1:4:8:1;06:2:1:1:4:8:1;06:4:4:8:1;17:4:11:1;17:4:6:6;12:1:4:4:6:6;12:1:4:4:6' \
            + ':6;011:6:6;07:1:3:4:1:1:6;03:2:2:1:3:4:1:1:3:1:2;02:13:1:1:6;02:3:2:8:1:1:2:2:2;' \
            + '02:8:1:6:2:2:2;02:2:1:5:1:6:1:3:2;02:2:1:3:1:1:1:6:2:2:2;02:5:1:2:1:6:2:2:2;02:5' \
            + ':1:2:1:6:2:2:2;02:8:9:2:2;023;023'
        
        p15 = '030;030;030;07:4:9:5:5;07:4:9:5:5;07:4:9:5:5;030;030;030;030;030;04:3:7:3:13;04:' \
            + '3:7:3:7:3:3;04:3:7:3:7:3:3;04:3:7:3:7:3:3;04:3:17:3:3;04:5:15:3:3;05:4:13:5:3;05' \
            + ':4:13:5:3;05:4:13:4:4;05:4:13:4:4;05:21:4;05:20:5;05:20:5;08:12:10;030;030;030;0' \
            + '30;030'


        puzzles = [p1, p2, p3, p4, p5, p6, p7, p8, p9, p10,
                   p11, p12, p13, p14, p15]
        return puzzles

    def big_puzzles():
        
        p1 = '05:2:2:2:1:6:9:18;05:2:2:2:1:6:16:11;05:2:2:2:3:2:23:6;02:18:22:3;05:2:2:2:3:2:1' \
            + '1:12:4:2;05:2:2:2:3:2:9:3:9:4:3:1;05:6:3:2:7:3:2:7:5:3:2;06:5:3:2:5:3:4:7:1:3:3:' \
            + '2:1;020:2:5:8:1:5:2:2;019:3:1:1:2:9:1:6:2:1;019:1:2:2:1:9:2:6:3;04:7:7:2:1:2:1:9' \
            + ':2:7:1:1:1;02:11:4:2:1:2:2:9:1:8:1:2;01:13:3:1:5:9:2:7:2:2;115:2:1:1:3:1:9:1:8:1' \
            + ':3;13:2:5:2:3:1:2:1:3:1:8:2:7:2:3;13:3:3:3:3:1:1:1:4:1:8:1:8:1:4;14:2:1:1:1:2:4:' \
            + '1:1:1:3:2:7:2:7:2:4;17:1:7:1:1:5:8:1:7:2:5;01:5:3:5:2:1:1:2:7:3:1:7:1:6;02:4:3:4' \
            + ':3:1:1:2:2:4:7:4:2:6;02:11:3:1:1:2:1:11:6:6:1;02:1:1:1:1:1:1:1:1:1:1:1:3:1:1:2:1' \
            + ':16:4:2:2;02:2:1:1:1:1:1:1:1:2:3:1:1:2:1:2:4:13:4:1;02:10:4:1:1:2:4:2:5:11:1:2;0' \
            + '3:9:4:2:1:1:1:9:5:6:2:2;11:4:5:7:1:1:1:2:12:5:1:2:3;12:15:1:2:1:1:16:3:4;13:14:2' \
            + ':1:1:1:18:1:4;14:14:2:2:17:2:3:1;15:14:1:7:12:1:3:1:1;17:12:2:2:3:4:9:1:2:2:1;11' \
            + '0:10:2:2:5:4:5:2:1:2:2;114:7:3:2:6:5:1:3:3:1;118:5:2:3:9:2:3:3'
        
        p2 = '140;140;17:6:27;18:15:17;17:24:9;14:3:33;14:3:33;14:3:33;14:3:14:14:5;15:2:14:14' \
            + ':5;15:2:4:4:2:4:3:3:4:4:5;15:2:4:5:2:3:2:3:2:1:2:4:5;15:2:3:6:3:2:2:3:3:1:2:3:5;' \
            + '15:2:3:5:5:1:1:5:5:3:5;15:2:3:5:5:1:1:5:5:3:5;15:2:3:5:5:1:1:5:5:3:5;15:2:3:4:1:' \
            + '1:3:2:1:4:1:1:4:3:5;15:2:3:4:1:3:1:2:2:1:2:2:4:3:5;15:2:3:5:1:5:4:2:5:3:5;15:2:3' \
            + ':6:2:3:3:2:6:3:5;15:2:2:2:1:5:4:4:5:1:2:1:6;15:2:5:7:2:2:7:4:6;16:1:4:2:1:7:7:1:' \
            + '2:3:6;16:1:3:2:2:7:7:2:1:3:6;16:1:6:2:1:5:5:1:2:5:6;16:1:5:2:1:2:1:3:3:1:1:2:2:3' \
            + ':7;16:1:8:2:1:3:3:1:2:6:7;16:1:7:2:2:3:3:2:2:5:7;16:1:10:2:1:1:1:1:2:7:8;16:1:10' \
            + ':2:1:1:1:1:2:7:8;16:1:7:4:2:1:1:2:3:4:9;16:1:9:1:3:1:1:9:9;16:1:13:1:1:8:10;118:' \
            + '3:3:5:11;117:2:1:3:1:4:12;120:1:1:5:13;120:1:1:4:14;120:5:15;121:2:17;140'
        
        p3 = '06:10:34;06:10:34;06:10:34;06:5:3:2:10:17:7;06:5:3:2:10:17:7;06:5:3:2:10:17:7;06' \
            + ':5:3:2:10:7:3:7:7;06:5:3:2:10:7:3:7:7;06:10:10:7:3:7:7;06:27:3:7:7;011:22:3:7:7;' \
            + '011:22:3:13:1;16:5:22:3:13:1;16:5:7:7:8:3:14;16:5:7:7:18:4:3;16:5:7:7:14:8:2:1;1' \
            + '6:5:7:7:14:11;16:1:24:3:5:11;07:9:2:14:2:5:3:6:2;07:9:2:6:5:10:3:6:2;07:10:1:6:5' \
            + ':3:2:5:3:6:2;07:17:2:6:2:5:3:6:2;07:2:2:13:2:13:11;07:2:2:3:3:7:2:12:12;07:6:5:6' \
            + ':2:6:2:14:2;07:6:5:6:2:6:2:14:2;07:17:2:6:2:14:2;07:25:2:5:3:6:2;07:21:1:2:3:2:1' \
            + ':2:3:6:2;09:8:6:8:3:2:1:2:3:6:2;09:8:6:8:3:14:2;09:3:1:4:6:4:2:2:3:14:2;09:4:1:3' \
            + ':6:4:2:2:3:4:1:5:1:3:2;09:8:6:4:3:1:3:14:2;09:8:6:3:1:4:3:14:2;09:8:6:8:19;09:2:' \
            + '1:5:6:8:19;09:8:6:5:1:2:19;09:8:6:5:1:2:19;09:8:6:8:19'
            
        p4 = '037:12:1;04:24:9:12:1;04:24:9:12:1;04:24:9:12:1;04:11:1:12:9:12:1;04:11:1:6:2:4:' \
            + '9:12:1;04:18:2:4:9:12:1;04:8:8:8:9:12:1;04:8:8:8:9:12:1;04:8:8:8:9:12:1;04:8:8:8' \
            + ':9:12:1;04:8:8:8:5:16:1;04:8:8:8:5:16:1;04:43:3;05:13:6:23:3;05:13:6:23:3;05:5:2' \
            + ':6:6:8:9:6:3;05:5:2:6:6:8:9:6:3;05:5:2:6:6:23:3;05:5:2:6:6:23:3;05:5:2:6:6:4:1:4' \
            + ':2:1:5:6:3;05:5:2:6:6:4:1:4:2:12:3;05:5:2:6:6:4:1:18:3;05:13:6:4:3:16:3;05:23:3:' \
            + '16:3;05:23:3:1:4:11:3;05:42:3;05:32:13;05:32:13;08:10:8:11:13;08:10:8:11:13;08:1' \
            + '0:8:11:1:6:6;08:6:4:19:1:6:6;08:6:4:19:1:6:6;08:6:4:2:4:13:1:6:6;114:4:2:4:5:2:6' \
            + ':1:6:6;18:4:8:4:5:2:6:1:6:6;18:8:4:4:13:13;11:2:5:8:4:4:4:1:8:13;11:2:8:5:16:1:4' \
            + ':1:10:2;127:1:9:1:10:2;124:2:11:1:10:2;137:1:10:2;08:29:1:10:2;011:4:12:4:7:10:2' \
            + ';011:4:12:4:7:10:2;011:4:12:4:7:10:2;011:4:12:4:7:10:2;011:4:12:4:19;011:4:12:4:' \
            + '19'
            
        p5 = '14:8:38;14:8:38;14:8:4:9:15:6:4;116:9:15:6:4;18:18:14:6:4;18:18:14:6:4;18:18:24;' \
            + '18:17:25;18:14:28;19:2:3:4:16:2:14;19:2:3:4:32;114:4:3:10:19;114:4:3:10:19;14:3:' \
            + '7:4:32;14:3:8:2:20:4:9;14:3:8:2:20:4:9;14:3:7:16:7:4:9;14:3:7:16:7:10:3;14:3:7:1' \
            + '6:7:10:3;114:16:7:10:3;114:16:8:9:3;133:3:2:9:3;133:3:2:9:3;133:3:2:9:3;138:9:3;' \
            + '138:9:3;126:16:8;112:4:10:16:8;112:4:6:3:25;17:5:38;17:5:38;17:5:33:2:3;15:1:39:' \
            + '2:3;15:1:11:7:21:2:3;117:7:21:2:3;117:7:18:1:7;117:7:16:3:7;117:7:16:3:7;17:1:9:' \
            + '5:18:2:8;17:1:9:5:28;117:5:28;16:10:34;16:10:12:13:9;16:10:12:13:9;16:10:12:13:9' \
            + ';150;144:2:1:1:2;144:3:3;146:1:3;147:1:2'
        
        p6 = '180;19:1:70;112:11:38:4:10:4:1;15:1:3:1:2:11:7:9:3:9:10:4:4:2:4:4:1;14:2:6:4:1:2' \
            + ':1:3:7:3:1:1:1:3:3:2:5:2:10:4:1:1:1:5:2:4:1;16:1:5:3:1:1:1:3:1:1:7:2:1:3:1:2:3:2' \
            + ':1:3:1:3:5:3:8:5:2:4:1;12:1:9:3:1:3:1:3:7:2:5:2:3:2:1:3:1:2:6:3:8:5:2:4:1;14:2:3' \
            + ':2:1:4:3:4:7:9:3:3:1:1:1:3:6:3:3:3:2:5:2:4:1;142:9:17:5:7;168:5:7'
        
        p7 = '150;13:9:38;13:9:38;13:9:24:3:11;13:9:7:20:11;13:9:7:17:14;13:9:7:17:7:7;13:9:7:' \
            + '17:7:7;126:10:7:7;128:8:7:2:2:3;06:12:1:6:1:2:9:4:4:2:3;06:22:9:4:4:2:3;06:10:1:' \
            + '11:1:7:1:6:2:2:3;06:22:1:7:1:6:2:2:3;06:11:1:9:2:7:1:6:2:2:3;012:5:1:9:2:7:1:3:2' \
            + ':1:7;012:7:2:3:1:1:1:9:1:3:2:1:7;012:10:2:11:2:3:2:1:7;14:8:28:2:1:7;14:8:28:2:1' \
            + ':7;14:8:28:2:1:7;14:8:7:4:5:3:3:1:5:2:4:2:2;14:8:7:4:6:2:3:1:5:2:4:2:2;14:8:7:4:' \
            + '6:2:9:2:4:2:2;14:8:2:3:2:4:6:1:2:10:4:2:2;119:4:9:8:6:2:2;120:6:6:8:6:2:2;17:1:1' \
            + ':5:18:8:10;19:5:18:8:10;19:5:4:1:31'
        
        p8 = '124:2:2:2:10;13:9:18:1:9;13:9:16:1:1:1:9;13:9:24:3:1;13:9:7:20:1;13:9:7:10:3:4:4' \
            + ';13:9:7:10:3:4:4;13:9:1:16:3:4:4;113:16:3:4:4;113:4:4:1:3:2:1:1:3:4:4;06:7:4:4:1' \
            + ':3:2:1:1:3:5:3;06:7:4:8:2:1:1:3:5:3;06:7:4:8:2:1:1:7:1:3;06:7:4:8:2:1:1:7:1:3;06' \
            + ':7:4:8:4:7:1:3;012:1:4:4:3:1:4:7:1:3;012:1:4:4:3:1:9:2:1:3;012:1:4:8:4:3:2:1:2:3' \
            + ';14:8:1:4:2:2:2:1:1:4:3:2:6;14:8:1:4:2:2:11:2:6;17:5:1:4:9:1:3:1:1:2:6;17:5:4:3:' \
            + '5:1:5:1:1:3:5;17:5:4:3:11:1:1:3:5;14:8:4:3:6:2:5:2:6;14:8:2:5:13:8;116:24;116:24' \
            + ';17:1:1:5:2:24;19:1:14:16;19:1:30;010:6:5:12:7;010:6:5:7:3:2:7;010:6:5:7:3:2:7;0' \
            + '10:6:5:7:3:2:7;04:24:3:2:7;04:24:3:2:7;04:6:13:5:3:2:7;04:6:24:2:4;04:6:30;040'
        
        p9 = '050;050;050;09:12:9:13:7;09:12:9:13:7;09:12:9:13:7;09:12:9:13:7;09:12:9:13:7;09:' \
            + '12:9:13:7;09:12:9:13:7;09:12:9:13:7;09:12:9:13:7;09:12:9:13:7;050;050;050;050;02' \
            + '3:5:22;023:5:22;023:5:22;023:5:22;023:5:22;023:5:22;023:5:22;023:5:22;023:5:22;0' \
            + '9:7:7:5:22;09:7:7:5:4:8:10;09:7:7:5:4:8:10;09:7:16:8:10;09:7:16:8:10;09:7:16:8:1' \
            + '0;09:7:16:8:10;09:11:10:10:10;09:11:10:10:10;014:6:8:12:10;014:6:8:12:10;014:6:8' \
            + ':5:17;014:6:8:5:17;014:19:17;014:18:18;014:18:18;019:10:21;019:10:21;050;050;050' \
            + ';050;050;050'
            
        p10 = '021:5:16;021:5:16;022:1:2:1:16;01:4:2:14:4:1:4:12;01:4:2:14:4:1:1:1:2:12;01:1:4:' \
            + '1:2:14:2:1:4:12;01:1:3:2:2:14:2:3:2:12;01:1:3:2:2:4:4:6:2:3:2:12;01:1:1:3:3:4:4:' \
            + '6:2:3:2:12;01:1:1:4:2:4:4:6:3:2:2:12;02:4:3:4:4:6:7:12;04:2:3:4:4:6:3:1:3:12;09:' \
            + '14:7:12;02:29:5:4:2;02:12:7:10:5:4:2;02:12:7:10:5:4:2;02:12:7:10:5:4:2;02:6:3:3:' \
            + '7:19:2;02:6:3:3:5:1:1:19:2;02:6:3:3:7:3:2:14:2;11:1:6:3:3:7:3:2:14:2;02:6:3:3:7:' \
            + '3:2:14:2;02:12:7:3:2:14:2;02:12:7:3:2:7:9;02:17:2:3:2:7:9;02:17:2:12:9;09:10:2:1' \
            + '2:9;09:10:4:5:4:8:2;09:10:2:10:1:8:2;09:10:2:10:1:8:2;09:10:2:10:1:8:2;04:3:2:8:' \
            + '4:10:1:8:2;04:3:2:7:5:10:1:8:2;04:3:2:11:10:4:3:3:2;04:3:2:11:10:4:3:3:2;04:3:2:' \
            + '2:3:6:8:6:3:3:2;04:3:2:2:3:6:8:6:3:3:2;04:3:2:2:3:6:8:5:9;04:3:2:2:3:6:8:5:9;04:' \
            + '3:2:2:3:19:9;04:3:2:2:3:18:10;03:31:3:3:2;03:26:1:4:3:3:2;03:26:1:4:3:3:2;030:10' \
            + ':2;030:10:2;030:10:2;030:10:2'

        puzzles = [p1, p2, p3, p4, p5, p6, p7, p8, p9, p10]

        return puzzles

    do_tests(mix_up(small_puzzles()), 'Small Random Tests')
    do_tests(mix_up(med_puzzles()), 'Medium Random Tests')
    do_tests(mix_up(big_puzzles()), 'Big Random Tests')


def sample_tests():

    def get_puzzles():
    
        h_clues = ((1, 1), (4,), (1, 1, 1), (3,), (1,))
        v_clues = ((1,), (2,), (3,), (2, 1), (4,))
        args = ((h_clues, v_clues), 5, 5)
    
        ans = ((0, 0, 1, 0, 0),
               (1, 1, 0, 0, 0),
               (0, 1, 1, 1, 0),
               (1, 1, 0, 1, 0),
               (0, 1, 1, 1, 1))
        
        t1 = (args, ans, '5 x 5 puzzle')
    
    
    
        h_clues = ((3,), (4,), (2, 2, 2), (2, 4, 2), (6,), (3,))
        v_clues = ((4,), (6,), (2, 2), (2, 2), (2,), (2,), (2,), (2,), (), (2,), (2,))
        args = ((h_clues, v_clues), 6, 11)
        
        ans = ((0, 1, 1, 1, 1, 0),
               (1, 1, 1, 1, 1, 1),
               (1, 1, 0, 0, 1, 1),
               (1, 1, 0, 0, 1, 1),
               (0, 0, 0, 1, 1, 0),
               (0, 0, 0, 1, 1, 0),
               (0, 0, 1, 1, 0, 0),
               (0, 0, 1, 1, 0, 0),
               (0, 0, 0, 0, 0, 0),
               (0, 0, 1, 1, 0, 0),
               (0, 0, 1, 1, 0, 0))
    
        t2 = (args, ans, '6 x 11 puzzle')
        
        
        
        h_clues = ((1, 1, 3), (3, 2, 1, 3), (2, 2), (3, 6, 3),
                   (3, 8, 2), (15,), (8, 5), (15,),
                   (7, 1, 4, 2), (7, 9,), (6, 4, 2,), (2, 1, 5, 4),
                   (6, 4), (2, 6), (2, 5), (5, 2, 1),
                   (6, 1), (3, 1), (1, 4, 2, 1), (2, 2, 2, 2))
        v_clues = ((2, 1, 1), (3, 4, 2), (4, 4, 2), (8, 3),
                   (7, 2, 2), (7, 5), (9, 4), (8, 2, 3),
                   (7, 1, 1), (6, 2), (5, 3), (3, 6, 3),
                   (2, 9, 2), (1, 8), (1, 6, 1), (3, 1, 6),
                   (5, 5), (1, 3, 8), (1, 2, 6, 1), (1, 1, 1, 3, 2))
        args = ((h_clues, v_clues), 20, 20)
        
        ans = ((1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1),
               (0, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1),
               (1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0),
               (0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0),
               (0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 1, 1),
               (0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1),
               (0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0),
               (0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0),
               (0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0),
               (0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0),
               (0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0),
               (0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1),
               (1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1),
               (1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0),
               (1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0),
               (0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0),
               (0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0),
               (0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0),
               (0, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1),
               (0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1))
        
        t3 = (args, ans, '20 x 20 puzzle')
        
        tests = [t1, t2, t3]
        return tests
    
    
    do_tests(get_puzzles(), 'Sample Tests')

sample_tests()
rand_tests()

#######################################################################
function solve(clues, width, height) {
    let field = Array.from({length:height}, () => Array.from({length:width}, () => -1));
    let linesChanged = clues.map(c => c.map(() => true));
    let isSolved = () => field.every(row => row.every(x => x != -1));
    let getCell = (line, cell, isVertical) => isVertical ? field[cell][line] : field[line][cell]; 
    let setCell = (line, cell, value, isVertical) => {isVertical ? (field[cell][line]=value) : (field[line][cell]=value);linesChanged[+isVertical][cell] = true;}
    let getLineLength = isVertical => isVertical ? height : width;
    let lineCounter = Array.from({length:Math.max(width, height)}, () => 0), pos = [], lineLength;
    let allCounters = [new Array(width), new Array(height)];
    let cluesMaxPos = clues.map((c, i) => c.map((clue) => clue.map((x, j) => getLineLength(!i)-(x+clue.reduce((a,y,k) => a+(y+1)*(k>j), 0)))));
    let updateLine = (line, isV) => {
        let counter = 0, result = false, clue = clues[+!isV][line], maxPos = cluesMaxPos[+!isV][line];
        lineCounter.fill(0);lineLength = getLineLength(isV);
        let setPos = index => {
            if (index >= clue.length) {
                if(index) for(let j=pos[index-1]+clue[index-1];j<lineLength;++j)if(getCell(line,j, isV)==1) return;
                counter++;
                for (let i=0; i <= clue.length; ++i){
                    for (let j=i?pos[i-1]+clue[i-1]:0; j < (i==clue.length ? lineLength : pos[i]);++j) lineCounter[j]--;
                    if (i != clue.length) for (let j=pos[i]; j<pos[i]+clue[i];++j) lineCounter[j]++;
                } 
            }else{
                let begin = index ? pos[index-1] + clue[index-1] + 1 : 0;
                for (pos[index] = begin; pos[index] <= maxPos[index] && (!pos[index] || getCell(line,pos[index]-1,isV) != 1); ++pos[index])
                    if (pos[index]+clue[index] == lineLength || getCell(line,pos[index]+clue[index],isV) != 1){
                        let ok = true;
                        for (let j = pos[index]; ok && j < pos[index]+clue[index]; ++j) ok = getCell(line,j,isV) != 0;
                        if (ok) setPos(index+1);
                    }
            }
        }
        setPos(0);
        if (!counter && clue.length) throw false;
        for (let i=0; i < lineLength; ++i) if (getCell(line, i, isV) == -1) {
            if (lineCounter[i] == -counter || lineCounter[i] == counter) {
                setCell(line, i, +!(lineCounter[i] == -counter), isV);result = true;
            }
        }
        linesChanged[+!isV][line] = false;allCounters[+isV][line] = counter;return result;
    }
    let solveByClues = () => {
        let changed;
        do{
            changed = false;
            for (let index = 0; index < 2; ++index){
                let i = width >= height ? index : 1-index;
                for (let k = 0; k < clues[i].length; ++k){
                    if (linesChanged[i][k] && updateLine(k, !i)) changed = true;
                }
            }
                    
        }while (changed);
    }
    solveByClues();
    if (!isSolved()){
        let getAllLines = (line, clue, isV) => {
            let variants = [];
            lineLength = getLineLength(isV);pos.length = lineLength;
            let setPos = index => {
                if (index >= clue.length) {
                    if(index) for(let j=pos[index-1]+clue[index-1];j<lineLength;++j)if(getCell(line,j, isV)==1) return;
                    variants.push(pos.concat()); 
                }else{
                    let begin = index ? pos[index-1] + clue[index-1] + 1 : 0;
                    for (pos[index] = begin; pos[index]+clue[index] <= lineLength && (!pos[index] || getCell(line,pos[index]-1,isV) != 1); ++pos[index])
                        if (pos[index]+clue[index] == lineLength || getCell(line,pos[index]+clue[index],isV) != 1){
                            let ok = true;
                            for (let j = pos[index]; ok && j < pos[index]+clue[index]; ++j) ok = getCell(line,j,isV) != 0;
                            if (ok) setPos(index+1);
                        }
                }
            }
            setPos(0);return variants;
        }
        let bruteForce = () => {
            let line, isV, minCounter = Infinity;
            for (let i = 0; i <= 1; ++i)
                for (let k = 0; k < allCounters[i].length; ++k)
                    if (allCounters[i][k] > 1 && allCounters[i][k] < minCounter){
                        minCounter = allCounters[i][k];line = k;isV = i;
                    }
            if (line == undefined) return true;
            let fieldCopy = field.map(s => s.concat());
            let linesChangedCopy = linesChanged.map(s => s.concat());
            let clue = clues[+!isV][line];
            let lineVariants = getAllLines(line, clue, isV);
            allCounters[isV][line] = 1;
            let allCountersCopy = allCounters.map(s => s.concat());
            for (let v = 0; v < lineVariants.length; ++v){
                if (v) {
                    field = fieldCopy.map(s => s.concat());
                    linesChanged = linesChangedCopy.map(s => s.concat());
                    allCounters = allCountersCopy.map(s => s.concat());
                }
                let pos = lineVariants[v];
                for (let i=0; i < clue.length; ++i){
                    for (let j=i?pos[i-1]+clue[i-1]:0; j < (i==clue.length ? lineVariants.length : pos[i]);++j) 
                        if (getCell(line, j, isV) == -1) setCell(line, j, 0, isV);
                    if (i != clue.length) 
                        for (let j=pos[i]; j<pos[i]+clue[i];++j) 
                            if (getCell(line, j, isV) == -1) setCell(line, j, 1, isV);
                }
                let result = true;
                try{solveByClues();}catch(error){result = false;}
                if (result && bruteForce()) return true; 
            }
            allCounters[isV][line] = minCounter;
            return false;
         }
        bruteForce();
    }
    return field; 
}

#####################################################
function solve(clues, width, height) {
    let field = Array.from({length:height}, () => Array.from({length:width}, () => -1));
    let linesChanged = clues.map(c => c.map(() => true));
    let isSolved = () => field.every(row => row.every(x => x != -1));
    let getCell = (line, cell, isVertical) => isVertical ? field[cell][line] : field[line][cell]; 
    let setCell = (line, cell, value, isVertical) => {
        isVertical ? (field[cell][line]=value) : (field[line][cell]=value);
        linesChanged[+isVertical][cell] = true;
    }
    let getLineLength = isVertical => isVertical ? height : width;
    let lineCounter = Array.from({length:Math.max(width, height)}, () => 0), pos = [], lineLength;
    let allCounters = [new Array(width), new Array(height)];
    let cluesMaxPos = clues.map((c, i) => c.map((clue) => clue.map((x, j) => getLineLength(!i)-(x+clue.reduce((a,y,k) => a+(y+1)*(k>j), 0)))));
    let updateLine = (line, isV) => {
        let counter = 0, result = false, clue = clues[+!isV][line], maxPos = cluesMaxPos[+!isV][line];
        lineCounter.fill(0);
        lineLength = getLineLength(isV);
        let setPos = index => {
            if (index >= clue.length) {
                if(index) for(let j=pos[index-1]+clue[index-1];j<lineLength;++j)if(getCell(line,j, isV)==1) return;
                counter++;
                for (let i=0; i <= clue.length; ++i){
                    for (let j=i?pos[i-1]+clue[i-1]:0; j < (i==clue.length ? lineLength : pos[i]);++j) lineCounter[j]--;
                    if (i != clue.length) for (let j=pos[i]; j<pos[i]+clue[i];++j) lineCounter[j]++;
                } 
            }else{
                let begin = index ? pos[index-1] + clue[index-1] + 1 : 0;
                for (pos[index] = begin; pos[index] <= maxPos[index] && (!pos[index] || getCell(line,pos[index]-1,isV) != 1); ++pos[index])
                    if (pos[index]+clue[index] == lineLength || getCell(line,pos[index]+clue[index],isV) != 1){
                        let ok = true;
                        for (let j = pos[index]; ok && j < pos[index]+clue[index]; ++j) ok = getCell(line,j,isV) != 0;
                        if (ok) setPos(index+1);
                    }
            }
        }
        setPos(0);
        if (!counter && clue.length) throw false;
        for (let i=0; i < lineLength; ++i) if (getCell(line, i, isV) == -1) {
            if (lineCounter[i] == -counter || lineCounter[i] == counter) {
                setCell(line, i, +!(lineCounter[i] == -counter), isV);
                result = true;
            }
        }
        linesChanged[+!isV][line] = false;
        allCounters[+isV][line] = counter;
        return result;
    }
    let solveByClues = () => {
        let changed;
        do{
            changed = false;
            for (let index = 0; index < 2; ++index){
                let i = width >= height ? index : 1-index;
                for (let k = 0; k < clues[i].length; ++k){
                    if (linesChanged[i][k] && updateLine(k, !i)) changed = true;
                }
            }
                    
        }while (changed);
    }
    solveByClues();
    if (!isSolved()){
        let getAllLines = (line, clue, isV) => {
            let variants = [];
            lineLength = getLineLength(isV);
            pos.length = lineLength;
            let setPos = index => {
                if (index >= clue.length) {
                    if(index) for(let j=pos[index-1]+clue[index-1];j<lineLength;++j)if(getCell(line,j, isV)==1) return;
                    variants.push(pos.concat()); 
                }else{
                    let begin = index ? pos[index-1] + clue[index-1] + 1 : 0;
                    for (pos[index] = begin; pos[index]+clue[index] <= lineLength && (!pos[index] || getCell(line,pos[index]-1,isV) != 1); ++pos[index])
                        if (pos[index]+clue[index] == lineLength || getCell(line,pos[index]+clue[index],isV) != 1){
                            let ok = true;
                            for (let j = pos[index]; ok && j < pos[index]+clue[index]; ++j) ok = getCell(line,j,isV) != 0;
                            if (ok) setPos(index+1);
                        }
                }
            }
            setPos(0);
            return variants;
        }
        let bruteForce = () => {
            let line, isV, minCounter = Infinity;
            for (let i = 0; i <= 1; ++i)
                for (let k = 0; k < allCounters[i].length; ++k)
                    if (allCounters[i][k] > 1 && allCounters[i][k] < minCounter){
                        minCounter = allCounters[i][k];
                        line = k;
                        isV = i;
                    }
            if (line == undefined) return true;
            let fieldCopy = field.map(s => s.concat());
            let linesChangedCopy = linesChanged.map(s => s.concat());
            let clue = clues[+!isV][line];
            let lineVariants = getAllLines(line, clue, isV);
            allCounters[isV][line] = 1;
            let allCountersCopy = allCounters.map(s => s.concat());
            for (let v = 0; v < lineVariants.length; ++v){
                if (v) {
                    field = fieldCopy.map(s => s.concat());
                    linesChanged = linesChangedCopy.map(s => s.concat());
                    allCounters = allCountersCopy.map(s => s.concat());
                }
                let pos = lineVariants[v];
                for (let i=0; i < clue.length; ++i){
                    for (let j=i?pos[i-1]+clue[i-1]:0; j < (i==clue.length ? lineVariants.length : pos[i]);++j) 
                        if (getCell(line, j, isV) == -1) setCell(line, j, 0, isV);
                    if (i != clue.length) 
                        for (let j=pos[i]; j<pos[i]+clue[i];++j) 
                            if (getCell(line, j, isV) == -1) setCell(line, j, 1, isV);
                }
                let result = true;
                try {
                    solveByClues();
                } catch (error) {
                    result = false;
                }
                if (result && bruteForce()) return true; 
            }
            allCounters[isV][line] = minCounter;
            return false;
         }
        bruteForce();
    }
    return field; 
}

#######################################################
function cluesToRe(clues, len) {
  if (clues.length === 0) {
    return arr => arr.every(el => el !== 1);
  }

  const last = new Int8Array(len);
  last[0] = -2;

  const stateMEM = [];

  for (let i = 0; i <= len; i++) {
    const row = [];
    for (let j = 0; j <= clues.length; j++) {
      row.push(new Set());
    }
    stateMEM.push(row);
  }

  stateMEM[0][0].add(0);

  return arr => {
    let start = 0;

    while ((start < len) && (last[start] === arr[start])) {
      start++;
    }

    let state = stateMEM[start];

    for (let j = start; j < len; j++) {
      const el = arr[j];
      last[j] = el;

      if (el === 0) {
        const newState = [];
        for (let i = 0; i <= clues.length; i++) {
          newState.push(new Set());
        }

        for (let i = 0; i < clues.length; i++) {
          const clue = clues[i];

          for (const k of state[i]) {
            if (k === clue) {
              newState[i + 1].add(0);
            }
            else if (k === 0) {
              newState[i].add(0);
              newState[i].add(1);
            }
            else {
              newState[i].add(k + 1);
            }
          }

          if (state[clues.length].size > 0) {
            newState[clues.length].add(0);
          }
        }
        state = newState;
      }
      else if (el === 1) {
        const newState = [];
        for (let i = 0; i <= clues.length; i++) {
          newState.push(new Set());
        }

        for (let i = 0; i < clues.length; i++) {
          const clue = clues[i];

          for (const k of state[i]) {
            if (k === clue) {
            }
            else if (k === 0) {
              newState[i].add(1);
            }
            else {
              newState[i].add(k + 1);
            }
          }
        }
        state = newState;
      }
      else if (el === 2) {
        const newState = [];
        for (let i = 0; i <= clues.length; i++) {
          newState.push(new Set());
        }

        for (let i = 0; i < clues.length; i++) {
          const clue = clues[i];

          for (const k of state[i]) {
            if (k === clue) {
              newState[i + 1].add(0);
            }
            else if (k === 0) {
              newState[i].add(0);
            }
            else {
            }
          }

          if (state[clues.length].size > 0) {
            newState[clues.length].add(0);
          }
        }
        state = newState;
      }
      else {
        throw Error(`Unexpected value: ${ el }`);
      }

      stateMEM[j + 1] = state;
    }

    let result = false;
    if (state[clues.length].size > 0) {
      result = true;
    }
    else if (state[clues.length - 1].has(clues[clues.length - 1])) {
      result = true;
    }

    return result;
  };
}

function deducePoint(line, clues, p) {
  line[p] = 2;
  const canBeEmpty = clues(line);
  
  line[p] = 1;
  
  const canBeFill = clues(line);
  line[p] = 0;

  if (canBeEmpty && canBeFill) {
    return 0;
  }
  else if (canBeFill) {
    return 1;
  }
  else if (canBeEmpty) {
    return 2;
  }
  else {
    return -1;
  }
}

function deduceField(field, clues, width, height) {
  clues = [ clues[0].map(clue => cluesToRe(clue, height)), 
            clues[1].map(clue => cluesToRe(clue, width)) ];

  const stack = [];
  for (let i = 0; i < height; i++) {
    stack.push(i);
  }
  for (let j = 0; j < width; j++) {
    stack.push(j + 20000);
  }

  while (stack.length > 0) {
    const t = stack.pop();

    if (t >= 20000) {
      const pj = t - 20000;
      for (let i = 0; i < height; i++) {
        if (field[i][pj] !== 0) continue;
        const d = deduce(i, pj);

        if (d === 0) continue;
        if (d === -1) return null;

        field[i][pj] = d;
        stack.push(i);
        stack.push(pj + 20000);
      }
    }
    else {
      const pi = t;
      for (let j = 0; j < width; j++) {
        if (field[pi][j] !== 0) continue;
        const d = deduce(pi, j);
        
        if (d === 0) continue;
        if (d === -1) return null;

        field[pi][j] = d;
        stack.push(pi);
        stack.push(j + 20000);
      }
    }
  }

  return field;

  function deduce(i, j) {
    if (field[i][j] !== 0) {
      return field[i][j];
    }

    const row = [];
    const col = field[i];

    for (let k = 0; k < height; k++) {
      row.push(field[k][j]);
    }

    const a = deducePoint(col, clues[1][i], j);
    const b = deducePoint(row, clues[0][j], i);

    if (a === -1 || b === -1) return -1;

    if (a !== 0) return a;
    if (b !== 0) return b;

    return 0;
  }
}

function solve(clues, width, height) {
  let field = [];
  for (let i = 0; i < height; i++) {
    const row = new Int8Array(width);
    row.fill(0);
    field.push(row);
  }

  let unChecked = [];
  for (let i = 0; i < height; i++) {
    for (let j = 0; j < width; j++) {
      unChecked.push([i, j]);
    }
  }

  field = deduceField(field, clues, width, height);
  unChecked = unChecked.filter(([i, j]) => field[i][j] === 0);
  
  while (unChecked.length > 0) {
    const [i, j] = unChecked[randInt(0, unChecked.length)];

    let tmpA = field.map(line => line.map(x => x));
    let tmpB = field.map(line => line.map(x => x));

    tmpA[i][j] = 1;
    tmpB[i][j] = 2;
    
    tmpA = deduceField(tmpA, clues, width, height);
    tmpB = deduceField(tmpB, clues, width, height);

    if (tmpA === null && tmpB === null) {
      throw Error("can't solve");
    }
    else if (tmpA === null) {
      field = tmpB;
      unChecked = unChecked.filter(([i, j]) => field[i][j] === 0);
    }
    else if (tmpB === null) {
      field = tmpA;
      unChecked = unChecked.filter(([i, j]) => field[i][j] === 0);
    }
  }

  return field.map(line => Array(...line.map(x => 2 - x)));
}

function randInt(min, max) {
  const d = max - min;

  return Math.floor(Math.random() * d) + min;
}

#####################################################
function cluesToRe(clues, len) {
  if (clues.length === 0) {
    return arr => arr.every(el => el !== 1);
  }

  const last = new Int8Array(len);
  last[0] = -2;

  const stateMEM = [];

  for (let i = 0; i <= len; i++) {
    const row = [];
    for (let j = 0; j <= clues.length; j++) {
      row.push(new Set());
    }
    stateMEM.push(row);
  }

  stateMEM[0][0].add(0);

  return arr => {
    let start = 0;

    while ((start < len) && (last[start] === arr[start])) {
      start++;
    }

    let state = stateMEM[start];

    for (let j = start; j < len; j++) {
      const el = arr[j];
      last[j] = el;

      if (el === 0) {
        const newState = [];
        for (let i = 0; i <= clues.length; i++) {
          newState.push(new Set());
        }

        for (let i = 0; i < clues.length; i++) {
          const clue = clues[i];

          for (const k of state[i]) {
            if (k === clue) {
              newState[i + 1].add(0);
            }
            else if (k === 0) {
              newState[i].add(0);
              newState[i].add(1);
            }
            else {
              newState[i].add(k + 1);
            }
          }

          if (state[clues.length].size > 0) {
            newState[clues.length].add(0);
          }
        }
        state = newState;
      }
      else if (el === 1) {
        const newState = [];
        for (let i = 0; i <= clues.length; i++) {
          newState.push(new Set());
        }

        for (let i = 0; i < clues.length; i++) {
          const clue = clues[i];

          for (const k of state[i]) {
            if (k === clue) {
            }
            else if (k === 0) {
              newState[i].add(1);
            }
            else {
              newState[i].add(k + 1);
            }
          }
        }
        state = newState;
      }
      else if (el === 2) {
        const newState = [];
        for (let i = 0; i <= clues.length; i++) {
          newState.push(new Set());
        }

        for (let i = 0; i < clues.length; i++) {
          const clue = clues[i];

          for (const k of state[i]) {
            if (k === clue) {
              newState[i + 1].add(0);
            }
            else if (k === 0) {
              newState[i].add(0);
            }
            else {
            }
          }

          if (state[clues.length].size > 0) {
            newState[clues.length].add(0);
          }
        }
        state = newState;
      }
      else {
        throw Error(`Unexpected value: ${ el }`);
      }

      stateMEM[j + 1] = state;
    }

    let result = false;
    if (state[clues.length].size > 0) {
      result = true;
    }
    else if (state[clues.length - 1].has(clues[clues.length - 1])) {
      result = true;
    }

    return result;
  };
}

function deducePoint(line, clues, p) {
  line[p] = 2;
  const canBeEmpty = clues(line);
  
  line[p] = 1;
  
  const canBeFill = clues(line);
  line[p] = 0;

  if (canBeEmpty && canBeFill) {
    return 0;
  }
  else if (canBeFill) {
    return 1;
  }
  else if (canBeEmpty) {
    return 2;
  }
  else {
    return -1;
  }
}

function deduceField(field, clues, width, height) {
  clues = [ clues[0].map(clue => cluesToRe(clue, height)), 
            clues[1].map(clue => cluesToRe(clue, width)) ];

  const stack = [];
  for (let i = 0; i < height; i++) {
    stack.push(i);
  }
  for (let j = 0; j < width; j++) {
    stack.push(j + 20000);
  }

  while (stack.length > 0) {
    const t = stack.pop();

    if (t >= 20000) {
      const pj = t - 20000;
      for (let i = 0; i < height; i++) {
        if (field[i][pj] !== 0) continue;
        const d = deduce(i, pj);

        if (d === 0) continue;
        if (d === -1) return null;

        field[i][pj] = d;
        stack.push(i);
        stack.push(pj + 20000);
      }
    }
    else {
      const pi = t;
      for (let j = 0; j < width; j++) {
        if (field[pi][j] !== 0) continue;
        const d = deduce(pi, j);
        
        if (d === 0) continue;
        if (d === -1) return null;

        field[pi][j] = d;
        stack.push(pi);
        stack.push(j + 20000);
      }
    }
  }

  return field;

  function deduce(i, j) {
    if (field[i][j] !== 0) {
      return field[i][j];
    }

    const row = [];
    const col = field[i];

    for (let k = 0; k < height; k++) {
      row.push(field[k][j]);
    }

    const a = deducePoint(col, clues[1][i], j);
    const b = deducePoint(row, clues[0][j], i);

    if (a === -1 || b === -1) return -1;

    if (a !== 0) return a;
    if (b !== 0) return b;

    return 0;
  }
}

function solve(clues, width, height) {
  let field = [];
  for (let i = 0; i < height; i++) {
    const row = new Int8Array(width);
    row.fill(0);
    field.push(row);
  }

  let unChecked = [];
  for (let i = 0; i < height; i++) {
    for (let j = 0; j < width; j++) {
      unChecked.push([i, j]);
    }
  }

  field = deduceField(field, clues, width, height);
  unChecked = unChecked.filter(([i, j]) => field[i][j] === 0);
  
  while (unChecked.length > 0) {
    const [i, j] = unChecked[randInt(0, unChecked.length)];

    let tmpA = field.map(line => line.map(x => x));
    let tmpB = field.map(line => line.map(x => x));

    tmpA[i][j] = 1;
    tmpB[i][j] = 2;
    
    tmpA = deduceField(tmpA, clues, width, height);
    tmpB = deduceField(tmpB, clues, width, height);

    if (tmpA === null && tmpB === null) {
      throw Error("can't solve");
    }
    else if (tmpA === null) {
      field = tmpB;
      unChecked = unChecked.filter(([i, j]) => field[i][j] === 0);
    }
    else if (tmpB === null) {
      field = tmpA;
      unChecked = unChecked.filter(([i, j]) => field[i][j] === 0);
    }
  }

  return field.map(line => Array(...line.map(x => 2 - x)));
}

function randInt(min, max) {
  const d = max - min;

  return Math.floor(Math.random() * d) + min;
}
