5c1d796370fee68b1e000611



from itertools import combinations

def solve_mine(mapStr, n):   return MineSweeper(mapStr, n).solve()

class MineSweeper(object):

    IS_DEBUG = False
    around   = [ (dx,dy) for dx in range(-1,2) for dy in range(-1,2) if (dx,dy) != (0,0) ]
    
    def __init__(self, mapStr, nMines):
        lines = mapStr.split('\n')
        mapDct, unknowns, posToWorkOn = {}, set(), set()
        for x,line in enumerate(lines):
            for y,c in enumerate(line.split(' ')):
                mapDct[(x,y)] = c
                if c == '?': unknowns.add((x,y))
                else:        posToWorkOn.add((x,y))
    
        self.map         = mapDct
        self.unknowns    = unknowns
        self.posToWorkOn = posToWorkOn
        self.flagged     = set()
        self.nMines      = nMines
        self.lX          = len(lines)
        self.lY          = len(lines[0].split(' '))
        
    
    
    def __str__(self):                return '\n'.join(' '.join( self.map[(x,y)] for y in range(self.lY)) for x in range(self.lX) )
    
    def getValAt(self,pos):           return int(self.map[pos])
    
    def getneighbors(self, pos):      return { (pos[0]+dx,pos[1]+dy) for dx,dy in self.around }
    
    def printDebug(self):             print(" \n------------\n{}\nRemaining mines: {}".format(self, self.nMines-len(self.flagged))) if self.IS_DEBUG else None
    
    def lookaroundThisPos(self, pos):
        neighbors = self.getneighbors(pos)
        return {'?': neighbors & self.unknowns,
                'x': neighbors & self.flagged}
        
    
    """ MAIN FUNCTION """
    def solve(self):
        
        self.printDebug()
        while True:
            while True:
                archivePosToWorkOn = self.posToWorkOn.copy()            # Archive to check against modifications
                
                self.openAndFlag_OnTheFly();       self.printDebug()    # Open and flag in the map while simple matches can be found
                self.complexSearch_OpenAndFlag();  self.printDebug()    # Use more complex algorithm to find mines or unknown positions that are surely openable
                
                if archivePosToWorkOn == self.posToWorkOn: break        # Repeat these two "simple" steps until its not possible to go further in the resolution
            
            self.complexSearch_CombineApproach()                        # Use witted combinatory approach to go further (if possible)
            
            if archivePosToWorkOn == self.posToWorkOn:
                break; self.printDebug()                                # Repeat these to "simple" steps until its not possible to go further in the resolution
        
        
        if len(self.flagged) == self.nMines:                            # If no more mines remaining but some unknown cases still there
            self.openThosePos(self.unknowns.copy())
            
        elif len(self.flagged) + len(self.unknowns) == self.nMines:     # If all the remaining "?" are mines, flag them
            self.flagThosePos(self.unknowns.copy())
        
        self.printDebug()
        
        return '?' if self.unknowns else str(self)
        
    
    def openAndFlag_OnTheFly(self):
        while True:
            openables, workDonePos = set(), set()
            for pos in self.posToWorkOn:                                    # Run through all the positions that might neighbors to open
                openables, workDonePos = [ baseSet|newPart for baseSet,newPart in zip((openables, workDonePos), self.openablePosaround_FlagOnTheFly(pos)) ]
            
            self.openThosePos(openables)                                    # After the exit of the loop, modification of self.posToWorkOn is possible, so:
            self.posToWorkOn -= workDonePos                                 # remove the pos with full number of mines from the working set (to fasten the executions)
            if not openables and not workDonePos: break     
    
    
    def openablePosaround_FlagOnTheFly(self, pos):
        around = self.lookaroundThisPos(pos)
        
        if self.getValAt(pos) == len(around['?']) + len(around['x']):       # If all the unknomn cases can be flagged (or if they are already!)...
            self.flagThosePos(around['?'])                                  # flag them (if not already done)
            return (set(), {pos})                                           # return the current position to remove it from self.posToWorkOn ("We're done with you..." / This behaviour will identify the "done" positions generated by the "witted approach")
            
        return (around['?'], {pos}) if self.getValAt(pos) == len(around['x']) else (set(), set())  
        
        
    def openThosePos(self, posToOpen):
        for pos in posToOpen:
            self.map[pos] = str(open(*pos))                                 # Open squares and update the map
            if self.map[pos] != '0': self.posToWorkOn.add(pos)              # Update slef.posToWorkOn if needed
        self.unknowns -= posToOpen                                          # Remove opened squares from the unknown positions
    
    
    def flagThosePos(self, posToFlag):
        for pos in posToFlag: self.map[pos] = 'x'                           # Flag mines
        self.unknowns -= posToFlag                                          # Remove flagged squares from the unknown positions
        self.flagged  |= posToFlag                                          # update the set of flagged positions
    
    
    def complexSearch_OpenAndFlag(self):
        markables, openables = set(), set()
        for pos in self.posToWorkOn:
            newMark, newOpen = self.intelligencia_OpenAndFlag(pos)
            markables |= newMark
            openables |= newOpen
            
        self.flagThosePos(markables)
        self.openThosePos(openables)
        
                
    def intelligencia_OpenAndFlag(self, pos):
        around       = self.lookaroundThisPos(pos)                          # Cases around the current position
        rMines        = [self.getValAt(pos)-len(around['x']), 0]            # Prepare an array with the number of remaining mines to find for the current position and the neighbor that will be worked on later
        neighToWorkOn = self.getneighbors(pos) & self.posToWorkOn           # Search for neighbors (only usefull ones, meaning: self.getValAt(posneighbor) is a number and this neighbor still miss some mines)
            
        markables, openables = set(), set()                                 # markables: position that will be flagged / openables: positions that will be open... of course... / fullUnion: stroe all the squares
        knownParts = []                                                     # knownParts: list of the intersections of the '?' cases of all the neighbors of the current pos and the current neighbor
        
        for pos2 in neighToWorkOn:
            around2  = self.lookaroundThisPos(pos2)                                         # Cases around the neighbor that is worked on right now
            rMines[1] = self.getValAt(pos2) - len(around2['x'])                             # Update the number of mines still to find for the current neighbor
            onlys     = [ around['?'] - around2['?'], around2['?'] - around['?'] ]          # Define the '?' that are owned only by the current "pos", and only by the current neighbor ("pos2")
            mInter    = max( n-len(only) for n,only in zip(rMines, onlys) )                 # Define the minimum (yes "minimum", even if "max" is used!) number of mines that have to be in the '?' that are commun to "pos" and it's current neighbor pos2"
            
            if mInter <= 0 or 1 not in rMines: continue                                     # If these conditions are met, there is nothing "extrapolable" at the current position, so continue the iteration
            
            currentIntersect = around['?'] & around2['?']
            if currentIntersect: knownParts.append(currentIntersect)                        # Store (if it exists) the current intersection of '?' cases for further checks

            for i in range(2):                                                              # Work on the two current LOCATIONS (pos, pos2)
                if len(onlys[i]) == rMines[i]-mInter:  markables |= onlys[i]                # The number of '?' cases that are only around the treated LOCATION matches the number mines of this LOCATION that are out of the interesction "pos & pos2". So, those cases will be flagged
                elif mInter == rMines[i]:              openables |= onlys[i]                # If the number of mines surely present in the intersection "pos & pos2" matches the number of mines still to found arorund the treated LOCATION, all the cases out of the intersection for the current LOCATION can be opened
            
        # Final check on the different intersections parts:
        fullIntersection = {posInter for posSet in knownParts for posInter in posSet}       # Union of all the intersections for the current position and its differente neighbors
        if len(knownParts) == rMines[0] and sum( len(s) for s in knownParts) == len(fullIntersection): 
            openables |= around['?'] - fullIntersection                                     # If some '?' cases are still unchecked while we can be sure that all the remaining mines are elsewhere (even without knowing their exact location), the leftovers can be opened
        
        return markables, openables
        
        
        
    def complexSearch_CombineApproach(self):
        rMines = self.nMines - len(self.flagged)                                            # number of remaining mines to find
        matchPos = []
        
        if rMines != 0:
            
            borderUnknowns = { pos2 for pos in self.posToWorkOn for pos2 in self.lookaroundThisPos(pos)['?'] }      # '?' that are joined to the current posToWorkOn...
            borderUnknowns |= { pos2 for pos in borderUnknowns for pos2 in self.lookaroundThisPos(pos)['?'] }       # ...then add the "next layer" of "?", ot be able to make more guesses on the remaining farther squares
            
            for n in range(rMines if not (self.unknowns-borderUnknowns) else 1, min(rMines, len(borderUnknowns)-1)+1):
                for posMines in combinations(borderUnknowns, n):
                    setPosMines = set(posMines)
                    for pos in self.posToWorkOn:
                        around = self.lookaroundThisPos(pos)
                        if self.getValAt(pos) != len(around['x']) + len(around ['?'] & setPosMines): break
                    else:
                        matchPos.append(setPosMines)                                                                # if the for loop execute until its end, the current position is valid. Archive it.
            
            untouched = borderUnknowns - {flagPos for s in matchPos for flagPos in s}                               # search for '?' that are never marked in any of the valid combinations
        
            if len(matchPos) == 1:  self.flagThosePos(matchPos[0])                                                  # Flag the found mines if only 1 match
            self.openThosePos(untouched)                                                                            # open the untouched '?' (free of mines!!)
            
            
#################
def solve_mine(map, n):
    if n==0:
        return map.replace('?','0')
    if n==map.count('?'):
        return map.replace('?','x')
    map=[r.split() for r in map.split('\n')]
    a,b=len(map),len(map[0])
    map={(i,j):map[i][j] for i in range(a) for j in range(b)}
    M,S,N, x = {},[],[],set()
    if a==29:map[(28,0)]=open(28,0) # Because one of the tests is wrong!!!
    while True:
        oldM = len(M)
        q = {i for i in map if map[i]=='?'}
        x = {i for i in map if map[i]=='x'}
        M = {i: int(map[i]) for i in map if i not in q|x}
        if len(M)==oldM: break
        S = {(frozenset(neig(i)&q), M[i]-len(neig(i)&x)) for i in M if neig(i)&q}
        if len(S)<20:
            S.add((frozenset(q), n-len(x)))
        while len(S)<250:
            oldS = len(S)
            S.update({(s2-s1, n2-n1) for s1,n1 in S for s2,n2 in S if (len(s2-s1)==n2-n1 or s1<=s2) and s1!=s2})
            if len(S)==oldS: break
        for s1,n1 in S:
            if n1==0:
                for t in s1:
                    map[t]=open(*t)
            if n1==len(s1):
                for t in s1:
                    map[t]='x' 
    return strmap(map,a,b) if len(x)==n else '?'
    
def neig(c):
    return {(c[0]+i,c[1]+j) for i in (1,0,-1) for j in (1,0,-1)}-{c}
def strmap(M,a,b):
    return '\n'.join(' '.join(str(M[(i,j)]) if (i,j) in M else '?' for j in range(b)) for i in range(a))
    
    
###################
neig = lambda c: {(c[0]+i,c[1]+j) for i in (1,0,-1) for j in (1,0,-1)}-{c}
def solve_mine(map, n):
    # Convert map to dict format : {(i,j): val}
    map  = [r.split() for r in map.split('\n')]
    a, b = len(map),len(map[0])
    map  = {(i,j): map[i][j] for i in range(a) for j in range(b)}
    
    size_q = a*b+1
    q = {i for i in map if map[i]=='?'} # cells with ?
    x = {i for i in map if map[i]=='x'} # cells with x
    e = {i:0 for i in map if map[i]=='0'} # empty cells (opened cells)
    while len(q) < size_q:
        # Set of constraints: (S, m) such that sum(S)=m
        C = {(frozenset(neig(i)&q), e[i]-len(neig(i)&x)) for i in e if neig(i)&q}
        if len(C) < 15: # <<Optimize this number>>
            C.add((frozenset(q), n-len(x)))
        size_C = -1
        while size_C<len(C)<200: # <<Optimize this number>>
            size_C = len(C)
            C.update({(S2-S1, m2-m1) for S1,m1 in C for S2,m2 in C if S2-S1 and (len(S2-S1)==m2-m1 or S1<=S2)})
        for S,m in C:
            if m == 0: # Open every cell in S since sum(S)=0
                for t in S:
                    map[t]=open(*t)
            if m == len(S): # Put x to every cell in S since sum(S)=|S|
                for t in S:
                    map[t]='x'
        for t in q: # Suppose there is no mine at t
            s = frozenset({t})
            C_ = {(S-s, m-1) for S,m in C if s<=S} # new C
            z = {i for S,m in C_ if m==0 for i in S} # there should be no mine at z
            for S,m in C_:
                if len(S-z)<m: # Contradiction, so open t safely
                    map[t]=open(*t)
                    break
        # Update
        size_q = len(q)
        q = {i for i in map if map[i]=='?'} # cells with ?
        x = {i for i in map if map[i]=='x'} # cells with x
        e = {i: int(map[i]) for i in map.keys()-(q|x)} # empty cells (opened cells)
    if len(x)==n:
        return '\n'.join(' '.join(str(map[(i,j)]) for j in range(b)) for i in range(a))
    return '?'
    
##########################
from itertools import combinations
from functools import reduce
from fractions import Fraction

def solve_mine(grid, mines):
    ll = grid.split('\n')
    G = {(r, c):(v if v == '?' else int(v)) for r, row in enumerate(ll) for c, v in enumerate(row.split())}
    NEIGHBOURS = {(r,c):{p for p in [(r-1,c-1),(r-1,c),(r-1,c+1),(r,c-1),(r,c+1),(r+1,c-1),(r+1,c),(r+1,c+1)] if p in G} for r, c in G}       
    MINES, UNKNOWN, ZEROS = {p for p in G if G[p] == 'x'}, {p for p in G if G[p] == '?'}, sum(G[p] == 0 for p in G)
    KNOWN = {p for p in G} - (MINES | UNKNOWN)    
        
    def add_mine(p): _, _, G[p]  = MINES.add(p), UNKNOWN.discard(p), 'x'
    def add_safe(p): _, _, G[p]  = KNOWN.add(p), UNKNOWN.discard(p), open(*p)    
    def ncr(n, r): return reduce(lambda x,y:x*y, (Fraction(n-i, i+1) for i in range(r)), 1)
    def solved(c):
        T = dict(G)
        m_near = lambda p: sum(T[n] == 'x' for n in NEIGHBOURS[p])
        for p in c: T[p] = 'x'
        for p in [p for p in T if T[p] == '?']: T[p] = m_near(p)    
        return ZEROS == sum(m_near(p) == 0 for p in T if T[p] != 'x') and all(m_near(p) == T[p] for p in T if T[p] != 'x')
        
        
    while True:
        lastlen = 'Pay your taxes'
        while lastlen != len(UNKNOWN):
            lastlen = len(UNKNOWN)
            for c in [e for e in KNOWN]:
                if c not in MINES | UNKNOWN:
                    u_near, m_near = NEIGHBOURS[c] & UNKNOWN, NEIGHBOURS[c] & MINES
                    if G[c] == len(m_near):               [add_safe(u) for u in u_near]
                    if G[c] == len(m_near) + len(u_near): [add_mine(u) for u in u_near]
            
        if mines == len(MINES):            
            for p in UNKNOWN: G[p] = len(NEIGHBOURS[p] & MINES)
            return '\n'.join(' '.join(str(G[(r,c)]) for c in range(len(ll[0].split()))) for r in range(len(ll)))
                
        # For each known square around which we are looking the mines store the mines needed and the set of possible locations of these mines
        S = {p:(G[p] - len(NEIGHBOURS[p] & MINES), NEIGHBOURS[p] & UNKNOWN) for p in KNOWN if G[p] - len(NEIGHBOURS[p] & MINES)}
        if S:
            # Loop to see if when removing any proper subsets we reveal mines or safe squares
            mn = min(len(v) for _, v in S.values())
            for n, ss in [(n, ss) for n, ss in S.values() if len(ss) == mn]:
                for k in S:
                    kn, ks = S[k]
                    if ss <= ks and ss != ks:                        
                        kn, ks = kn - n, ks -ss
                        S[k] = (kn, ks)
                        if kn == len(ks): [add_mine(e) for e in ks]
                        elif kn == 0:     [add_safe(e) for e in ks]  
                                        
        if lastlen == len(UNKNOWN):                    
            if ncr(len(UNKNOWN), mines - len(MINES)) > 1010: return '?'

            overlaps = MINES | UNKNOWN | KNOWN
            for p in [set(c) for c in combinations(UNKNOWN, mines - len(MINES)) if solved(c)]: overlaps &= p            
            if not overlaps: return '?'    
            
            for e in overlaps: add_mine(e)   
            
#############################
def solve_mine(map, n):
    # coding and coding...
    import copy
    import itertools
    import time

    # First some functions...  
    def list_game(map):
        """Converts list string into a 2d array of ints where -1 means ?
           Set globals nRows and nCols"""
        lGame = map.split('\n')
        global nRows
        global nCols
        nRows = len(lGame)

        for row in range(nRows):
            lGame[row] = lGame[row].split(' ')
            if row == 0:
                nCols = len(lGame[0])
            for col in range(nCols):
                lGame[row][col] = -1 if lGame[row][col] == '?' else int(lGame[row][col])
        return lGame
        
    def string_game(lGame):
        """Converts 2d array back to string for output"""
        mGame = copy.deepcopy(lGame)
        for row in range(nRows):
            for col in range(nCols):
                if mGame[row][col] == -1:
                    mGame[row][col] = '?'
                elif mGame[row][col] == -2:
                    mGame[row][col] = 'x'
                elif mGame[row][col] == -3:
                    mGame[row][col] = '0'
                else:
                    mGame[row][col] = str(mGame[row][col])
            mGame[row] = ' '.join(mGame[row])
        return '\n'.join(mGame)
        
    def check_won(lGame):
        """Returns True if won. Else return false"""
        for row in lGame:
            if -1 in row:
                return False
        return True
        
    def clear_zero(lGame, row, col):
        """Clears neighbors of a box"""
        lGame[row][col] = -3
        for trow in [row - 1, row, row + 1]:
            for tcol in [col - 1, col, col + 1]:
                if trow >= 0 and tcol >= 0 and trow < nRows and tcol < nCols:
                    if lGame[trow][tcol] == -1:
                        lGame[trow][tcol] = open(trow, tcol)
                    if lGame[trow][tcol] == 0:
                        clear_zero(lGame, trow, tcol)
        return lGame
        
  
    def clear_all_zeroes(lGame):
        """Clears all zeroes on the board"""
        start = time.time()
        changes = 0
        for row in range(nRows):
            for col in range(nCols):
                if lGame[row][col] == 0:
                    lGame = clear_zero(lGame, row, col)
                    changes += 1
        elapsed = str(time.time() - start)
        print('Cleared all zeroes. Time: ' + elapsed)
        return lGame, changes
        
    def list_neighbors(lGame, row, col):
        """Returns a list of the neighbors surrounding a box. The entries of
           the list are a list of the form [row, col, value]. Also returns 
           the number of unknowns and bombs around a box"""
        neighbors = []
        unknowns = 0
        bombs = 0
        for trow in [row - 1, row, row + 1]:
            for tbox in [col - 1, col, col + 1]:
                if trow >= 0 and tbox >= 0 and trow < nRows and tbox < nCols:
                    if trow != row or tbox != col:
                        value = lGame[trow][tbox]
                        neighbors.append([trow, tbox, value])
                        if value == -1:
                            unknowns += 1
                        if value == -2:
                            bombs += 1
        return neighbors, unknowns, bombs
                        
    
    
    def mark_knowns(lGame):
        """Looks through all numbered boxes with unknown neighbors and marks 
           bombs if all unknown are bombs. If all bombs are accounted for, it
           clears the neighborhood"""
        start = time.time()
        changes = 0
        for row in range(nRows):
            for box in range(nCols):
                if lGame[row][box] > 0:
                    neighbors, unknowns, bombs = list_neighbors(lGame, row, box)
                    if lGame[row][box] - bombs == unknowns:
                        for trow in [row - 1, row, row + 1]:
                            for tbox in [box - 1, box, box + 1]:
                                if trow >= 0 and tbox >= 0 and trow < nRows and tbox < nCols:
                                    if lGame[trow][tbox] == -1:
                                        lGame[trow][tbox] = -2
                                        changes += 1
                    if lGame[row][box] - bombs == 0:
                        for trow in [row - 1, row, row + 1]:
                            for tbox in [box - 1, box, box + 1]:
                                if trow >= 0 and tbox >= 0 and trow < nRows and tbox < nCols:
                                    if lGame[trow][tbox] == -1:
                                        lGame[trow][tbox] = open(trow, tbox)
                                        changes += 1
        
        elapsed = str(time.time() - start)
        print('Cleared all obvious boxes. Time: ' + elapsed)
        return lGame, changes

    def get_combos(lGame, n):
        """Returns list of remaining unknown locations as well as the number 
           of bombs remaining"""
        borders = []
        bombs = 0
        totalUK = 0
        for row in range(nRows):
            for col in range(nCols):
                if lGame[row][col] == -1:
                    totalUK += 1
                    neighbors, dummy1, dummy2 = list_neighbors(lGame, row, col)
                    if any(neighbor[2] > 0 for neighbor in neighbors):
                        borders.append([row, col])
                elif lGame[row][col] == -2:
                    bombs += 1
        
        # In case where there are no unknowns on border, we will use all unknowns
        if len(borders) == 0:
            for row in range(nRows):
                for col in range(nCols):
                    if lGame[row][col] == -1:
                        borders.append([row, col])
        
        remainder = n - bombs
        low = remainder - totalUK + len(borders)
        if low < 1:
            low = 1
        combos = []
        for i in range(low, remainder + 1):
            combos += list(itertools.combinations(borders, i))
        nCombos = len(combos)
        print('Bombs remaining: ' + str(remainder))
        print('Local unknowns: ' + str(len(borders)))
        print('Combinations: ' + str(nCombos))
        return combos, nCombos, borders, remainder
    
    def pick_subjects(lGame, unknowns):
        """Finds the neighbors of unknowns to check later"""
        subjects = []
        for uk in unknowns:
            neighbors, uks, bombs = list_neighbors(lGame, uk[0], uk[1])
            for neighbor in neighbors:
                if neighbor not in subjects and neighbor[2] >= 0:
                    subjects.append(neighbor)
        return subjects
    
    def test_local(tGame, subjects):
        """Tests the neighbors of prospective bombs for errors"""
        for subject in subjects:
            neighbors, dummy, neighbombs = list_neighbors(tGame, subject[0], subject[1])
            if neighbombs != tGame[subject[0]][subject[1]]:
                return False
        return True
    

    
    def trial_and_error(lGame, n):
        """Performs trial and error to solve remaining boxes"""
        start = time.time()
        combos, nCombos, borders, remainder = get_combos(lGame, n)
        
        # Case where no bombs remain
        if remainder == 0:
            for row in range(nRows):
                for col in range(nCols):
                    if lGame[row][col] == -1:
                        lGame[row][col] = open(row, col)
            return lGame
        
        subjects = pick_subjects(lGame, borders)
        winners = []
        for combo in combos:
            tGame = copy.deepcopy(lGame)
            for bomb in combo:
                tGame[bomb[0]][bomb[1]] = -2
            if test_local(tGame, subjects):
                winners.append(copy.deepcopy(tGame))
            else:
                continue
        if len(winners) == 0:
            elapsed = time.time() - start
            print('No solution found. Time: ' + str(elapsed))
            try:
                print('Time per combo: ' + str(elapsed / nCombos))
            except ZeroDivisionError:
                pass
            return '?'
        elif len(winners) == 1:
            print('One solution found...')
            for row in range(nRows):
                for col in range(nCols):
                    if winners[0][row][col] == -1:
                        winners[0][row][col] = open(row, col)
            elapsed = time.time() - start
            print('One solution found. Time: ' + str(elapsed))
            try:
                print('Time per combo: ' + str(elapsed / nCombos))
            except ZeroDivisionError:
                pass
            return winners[0]
        else:
            print(str(len(winners)) + ' solutions found.')
            lGame = find_common(lGame, borders, winners)
            elapsed = time.time() - start
            print('Trial and error completed. Time: ' + str(elapsed))
            try:
                print('Time per combo: ' + str(elapsed / nCombos))
            except ZeroDivisionError:
                pass
            return lGame
        
    def find_common(lGame, unknowns, winners):
        """Searches through a list of winners, checking if any of the unknows
        have a common value"""
        locations = []
        values = []
        nWinners = len(winners)
        for unknown in unknowns:
            test = winners[0][unknown[0]][unknown[1]]
            test_count = 1
            for winner in range(1, nWinners):
                if winners[winner][unknown[0]][unknown[1]] != test:
                    break
                else:
                    test_count += 1
            if test_count == nWinners:
                values.append(test)
                locations.append(unknown)
        if len(values) == 0:
            return '?'
        else:
            for ind, val in enumerate(values):
                if val == -2:
                    lGame[locations[ind][0]][locations[ind][1]] = -2
                else:
                    lGame[locations[ind][0]][locations[ind][1]] = open(locations[ind][0],locations[ind][1])
            return lGame
                
                    
        
    ### BEGIN PLAYING GAME HERE ###
    complete_start = time.time()
    lGame = list_game(map)
    print('Begin solving...')
    print('Number of rows: ' + str(nRows))
    print('Number of columns: ' + str(nCols))
    print('Number of boxes: ' + str(nRows * nCols))
    print('Number of bombs: ' + str(n))
    print('')
    
    # Deal with trivial cases
    if nRows == 1 and nCols == 1:
        if n == 1:
            return'x'
        else:
            return '0'
    
    count = 0
    while not check_won(lGame) and count < 10:
        print('')
        print('Begin loop ' + str(count))
        zchanges, mchanges = 0, 0
        lGame, zchanges = clear_all_zeroes(lGame)
        lGame, mchanges = mark_knowns(lGame)
        if zchanges + mchanges == 0:
            print('Begin performing trial and error...')
            print('')
            print(string_game(lGame))
            print('')
            lGame = trial_and_error(lGame, n)
            if lGame == '?':
                elapsed = str(time.time() - complete_start)
                print('Total time to solve: ' + elapsed)
                return '?'

        count += 1
    
    elapsed = str(time.time() - complete_start)
    print('Total time to solve: ' + elapsed)
    return string_game(lGame)
    
######################
import numpy as np
import queue
from itertools import permutations


class Minefield:
    def __init__(self, minefield, number_of_bombs):
        self.minefield, self.starting_positions = self.parse_map(minefield)
        self.n = number_of_bombs

    def solve(self):
        q = queue.Queue()
        [q.put(x) for x in self.starting_positions]
        maybe_stuck = 0

        while 1:

            if (self.n - self.bombs_found() <= 0 and len(self.question_marks()) == 0) or q.empty():

                if self.n - self.bombs_found() <= 0 and len(self.question_marks()) > 0:
                    for qm in self.question_marks():
                        qm.value = open(qm.y, qm.x)

                if self.n - self.bombs_found() == len(self.question_marks()):
                    if self.n - self.bombs_found() > 0:
                        for qm in self.question_marks():
                            qm.value = 'x'

                if self.solved():
                    return self.map_to_string()

                if maybe_stuck == 0:
                    # Put numbers adjacent to question marks in queue
                    qms = self.question_marks()
                    to_queue = set()
                    for qm in qms:
                        [to_queue.add(number) for number in qm.nearby_numbers()]
                        [q.put(x) for x in to_queue]
                    maybe_stuck = 1
                    continue
                else:
                    type, solution = self.solve_stuck()
                    if solution:
                        # print(solution)
                        # print('found a unique solution to this pickle')
                        if type == 'mines':
                            for bomb in solution:
                                bomb.value = 'x'
                        if type == 'safe':
                            for confirmed_safe in solution:
                                confirmed_safe.value = int(open(confirmed_safe.y, confirmed_safe.x))

                        # print(minefield.minefield)

                        qms = self.question_marks()
                        to_queue = set()
                        for qm in qms:
                            [to_queue.add(number) for number in qm.nearby_numbers()]
                            [q.put(x) for x in to_queue]
                        maybe_stuck = 0
                        continue

                    # print(f'stuck at ({len(minefield.question_marks())} question marks)')
                    # print(f'{n- minefield.bombs_found()} bombs remaining')
                    print(self.minefield)
                    return '?'

            box = q.get()
            unknowns = box.nearby_unknowns()
            bombs = box.nearby_bombs()

            # If all nearby bombs have been found, open everything else
            if len(unknowns) > 0 and box.value == len(bombs):
                for guy in unknowns:
                    guy.value = int(open(guy.y, guy.x))
                    q.put(guy)
                    maybe_stuck = 0

            unknowns = box.nearby_unknowns()
            bombs = box.nearby_bombs()
            # Find bombs
            if box.value == len(unknowns)+len(bombs):
                for guy in unknowns:
                    guy.value = 'x'
                    maybe_stuck = 0

    def solve_stuck(self, test_bombs=0):
        bombs_remaining = self.n - self.bombs_found()

        # Just a test parameter, ignore
        if test_bombs:
            bombs_remaining = test_bombs

        all_qms = self.question_marks()
        numbers = set()
        qms = set()
        for qm in all_qms:
            [numbers.add(number) for number in qm.nearby_numbers()]
        for number in numbers:
            [qms.add(qm) for qm in number.nearby_unknowns()]

        # Can change this if '?'s take too long
        if len(self.question_marks())*bombs_remaining > 100 and len(self.question_marks()) != len(qms):
            return None, False

        # picks 2 question marks at random to check if they could be it
        posibilities = []

        if len(all_qms) == len(qms):
            bomb_range = range(bombs_remaining, bombs_remaining+1)
        else:
            bomb_range = range(1, bombs_remaining+1)

        for bomb_amount in bomb_range:
            ps = permutations(list(qms), bomb_amount)
            posibilities += list(set([tuple(sorted(p)) for p in ps]))

        unique_solution = True
        solution = None

        possible_values = []

        for posibility in posibilities:
            # turn all cases to 'x'
            for bomb in posibility:
                bomb.value = 'x'

            # see if it's a valid solution
            for number in numbers:
                if number.value != number.n_nearby_bombs():

                    for bomb in posibility:
                        bomb.value = '?'
                    # print(f'{number.nearby_bombs()}')
                    # print(f'{number.value} at {number.y}, {number.x} wasnt satisfied')
                    break
            else:
                bad = False
                if len(posibility) == bombs_remaining:
                    for qm in self.question_marks():
                        if qm.n_nearby_bombs() == 0:
                            # print(f'empty spot at {qm.y}, {qm.x}')
                            bad = True

                else:
                    for qm in qms:
                        if qm.value != 'x':
                            if qm.n_nearby_bombs() == 0:
                                # print(f'empty spot at {qm.y}, {qm.x}')
                                bad = True

                if bad is False:
                    possible_values.append(posibility)
                    if solution:
                        for bomb in posibility:
                            bomb.value = '?'
                        unique_solution = False
                    if len(self.question_marks()) >= bombs_remaining:
                        solution = posibility

                for bomb in posibility:
                    bomb.value = '?'

        # PRINT POSSIBLE_VALUES:
        # print(possible_values)
        # print('Possible values at:')
        # for ps in possible_values:
        #     print(ps)
        #     for dimension in ps:
        #         print(f'{dimension.y}, {dimension.x}')
        # print('we see they all agree on 1,1, so its gotta be correct')
        # END PRINT POSSIBLE_VALUES
        # GET VALUE IN COMMON FROM POSSIBLE_VALUES
        cpv = common_possible_values(possible_values)
        if cpv == []:
            safe_cases = unseen_possible_values(possible_values, qms)
        # if we don't have a solution, we return cpv
        # print('cpv', cpv)
        # print(self.minefield)
        if solution and unique_solution is True:
            return ('mines', solution)
        elif cpv != []:
            return ('mines', cpv)
        else:
            return ('safe', safe_cases)

    def parse_map(self, gamefield):
        self.bombs_remaining = 0
        starting_positions = []
        minefield = np.array([x.split(' ') for x in gamefield.split('\n')],
                             dtype=np.object)

        for y, row in enumerate(minefield):
            for x, value in enumerate(row):
                minefield[y, x] = Node(y, x, value)
                if value != '?':
                    self.bombs_remaining += 1
                    starting_positions.append(minefield[y, x])

        for row in minefield:
            for node in row:
                node.get_paths(minefield)

        return minefield, starting_positions

    def map_to_string(self):
        rows = []
        for row in self.minefield:
            rows.append(' '.join([str(node.value) for node in row]))
        return '\n'.join(rows)

    def solved(self):
        for row in self.minefield:
            for node in row:
                if node.value == '?':
                    return False
        else:
            return True

    def question_marks(self):
        qs = []
        for row in self.minefield:
            for node in row:
                if node.value == '?':
                    qs.append(node)
        return qs

    def bombs_found(self):
        bs = []
        for row in self.minefield:
            for node in row:
                if node.value == 'x':
                    bs.append(node)
        return len(bs)


class Node:
    def __init__(self, y, x, value):
        self.y = y
        self.x = x
        # Turns numbers into ints and leaves question marks
        self.value = value if value == '?' or value == 'x' else int(value)

    def get_paths(self, minefield):
        self.paths = []
        height, width = minefield.shape

        if self.y > 0 and self.x > 0:
            self.paths.append(minefield[self.y-1, self.x-1])
        if self.y < height-1 and self.x > 0:
            self.paths.append(minefield[self.y+1, self.x-1])
        if self.x < width-1 and self.y > 0:
            self.paths.append(minefield[self.y-1, self.x+1])
        if self.x < width-1 and self.y < height-1:
            self.paths.append(minefield[self.y+1, self.x+1])

        if self.y > 0:
            self.paths.append(minefield[self.y-1, self.x])
        if self.y < height-1:
            self.paths.append(minefield[self.y+1, self.x])
        if self.x > 0:
            self.paths.append(minefield[self.y, self.x-1])
        if self.x < width-1:
            self.paths.append(minefield[self.y, self.x+1])

    def nearby_unknowns(self):
        return [box for box in self.paths if box.value == '?']

    def nearby_bombs(self):
        return [box for box in self.paths if box.value == 'x']

    def nearby_numbers(self):
        return [box for box in self.paths if isinstance(box.value, int)]

    def n_nearby_unknowns(self):
        return sum(1 for box in self.paths if box.value == '?')

    def n_nearby_bombs(self):
        return sum(1 for box in self.paths if box.value == 'x')

    def n_nearby_numbers(self):
        return sum(1 for box in self.paths if isinstance(box.value, int))

    def __repr__(self):
        return str(self.value)

    def __gt__(self, other):
        return id(self) > id(other)


def common_possible_values(possible_values):

    values = set()
    for guy in possible_values:
        for ps in guy:
            values.add(ps)

    values = list(values)
    common_values = []

    for value in values:
        for every_one in possible_values:
            if value not in every_one:
                break
        else:
            common_values.append(value)
    
    return common_values


def unseen_possible_values(possible_values, unknowns):
    qms = list(unknowns)
    values = set()
    for guy in possible_values:
        for ps in guy:
            values.add(ps)

    values = list(values)
    unseen_values = []
    # print(values)
    # print(qms)

    for qm in qms:
        if qm not in values:
            unseen_values.append(qm)

    return unseen_values


def solve_mine(mapa, n):
    minefield = Minefield(mapa, n)
    return minefield.solve()

# TESTING


s = '''
1 ? ?
2 ? ?
x 2 1
'''.strip()
# this one has 3 bombs V
s = '''
1 2 x 1
? ? 2 1
? ? 2 1
? ? 2 x
? ? ? 2
? ? ? 1
'''.strip()
s = '''
x 2 1
2 ? ?
1 ? ?
2 ? ?
2 ? ?
2 ? ?
'''.strip()
s = '''
1 2 2 1 0 0
2 x x 2 1 1
2 3 ? ? ? ?
1 1 ? ? ? ?
'''.strip()
s = '''
x 2 x 2 x 1 1 x 2 1
1 2 1 2 1 1 1 2 ? ?
0 0 1 1 1 0 0 1 ? ?
0 0 1 x 1 1 1 2 ? ?
0 0 1 1 1 1 x 2 ? ?
0 0 0 0 0 1 1 2 ? ?
'''.strip()
# s = '''
# 1 ? 1 0 0 1 ? 1
# 2 ? 2 2 2 3 ? 2
# x 3 ? ? ? ? ? 1
# 1 2 ? ? ? ? ? 2
# 0 1 ? ? ? ? ? 1
# '''.strip()
s = '''
x 1 ?
? ? ?
? ? ?
'''.strip()

#########################
from itertools import combinations
from collections import defaultdict

# Too lazy to clean it \o/
class Grid:
    def __init__(self, i, j):
        self.i = i
        self.j = j
        self.neighbors = set()
        self.constraints = set()
        self.original = None
        self.mine = 0
        self.value = None
        self.probed = False
        self.revealed = False
        self.marks = 0
        self.flag = False
    
    def __hash__(self):
        return hash((self.i, self.j))
    
    def __eq__(self, other):
        return self.i == other.i and self.j == other.j
    
    def __repr__(self):
        return f"({self.i}, {self.j})"

def solve_mine(map, n):
    def neighbors_count(grid):
        mines = safe = left = 0
        for g in grid.neighbors:
            if g.value == 1:
                mines += 1
            elif g.value == 0:
                safe += 1
            else:
                left += 1
        return mines, safe, left
    
    
    def check_constraints(grid, x):
        grid.value = x
        for g in grid.neighbors:
            if g.revealed and g.value == 0:
                mines, safe, left = neighbors_count(g)
                if mines > g.original or g.original > mines+left:
                    return False
        return True
    
    
    def check_valid(squares, check):
        valid = all(check_constraints(s, c) for s,c in zip(squares, check))
        for s in squares:
            s.value = None
        return valid
            
    
    def backtrack():
        def rec(check):
            if len(check) <= left and sum(check) <= n:
                for x in (0, 1):
                    check.append(x)
                    if len(check) == left:
                        if test and sum(check) == n or not test and sum(check) <= n:
                            if check_valid(squares, check):
                                res.append(check[:])
                    rec(check)
                    del check[-1]
                return res
            
        squares = list({g for grid in moves for g in grid.constraints})
        left, res = len(squares), []
        test = sum(grid.value is None for row in game for grid in row) == left
        if n < left:
            rec([])
        safe = False
        if res:
            counts = defaultdict(int)
            for r in res:
                for s,x in enumerate(r):
                    counts[squares[s]] += x
            for s,c in counts.items():
                if not c:
                    safe = True
                    probe.add(s)
        return safe
    
    
    def compare(g1, g2):
        to_remove = set()
        if g1.constraints and g2.constraints:
            if g2.constraints < g1.constraints:
                return compare(g2, g1)
            if g1.constraints <= g2.constraints:
                g2.constraints -= g1.constraints
                g2.mine += g1.original - g1.mine
                if g2.original == g2.mine and g2.constraints:
                    while g2.constraints:
                        probe.add(g2.constraints.pop())
                    to_remove.add(g2)
                elif 0 < g2.original - g2.mine == len(g2.constraints):
                    while g2.constraints:
                        mark(g2.constraints.pop(), True)
                    to_remove.add(g2)
                if 0 < g1.original - g1.mine == len(g1.constraints):
                    while g1.constraints:
                        mark(g1.constraints.pop(), True)
                    to_remove.add(g1)
        return to_remove
    
    
    def simplify():
        to_remove = set()
        for grid in moves:
            if grid.original - grid.mine == len(grid.constraints):
                while grid.constraints:
                    mark(grid.constraints.pop(), True)
                to_remove.add(grid)
            elif grid.original == grid.mine:
                while grid.constraints:
                    probe.add(grid.constraints.pop())
                to_remove.add(grid)
        moves.difference_update(to_remove)
        to_remove.clear()
        if len(moves) > 1:
            for g1,g2 in combinations(moves, 2):
                to_remove.update(compare(g1, g2))
        moves.difference_update(to_remove)
            
    
    def mark(grid, mine):
        nonlocal n
        grid.marks += 1
        # Add to marked?
        if grid.value is None:
            if mine:
                map[grid.i][grid.j] = "x"
                n -= 1
                grid.value = 1
                grid.flag = True
            else:
                map[grid.i][grid.j] = str(grid.original)
                grid.value = 0
            for g in grid.neighbors:
                if grid in g.constraints:
                    g.constraints.remove(grid)
                    if mine:
                        g.mine += 1

    
    def reveal(grid):
        if not grid.probed:
            grid.probed = True
            grid.revealed = True
            grid.original = open(grid.i, grid.j)
            mark(grid, False)
            if grid.original == 0:
                for g in grid.neighbors:
                    reveal(g)
            else:
                moves.add(grid)
    
    
    def start():
        while probe:
            reveal(probe.pop())
            simplify()
            
        if n and moves:
            if backtrack():
                start()

        if n:
            grids = [grid for row in game for grid in row if grid.value is None]
            if len(grids) == n:
                for grid in grids:
                    mark(grid, True)
        else:
            for row in game:
                for grid in row:
                    if grid.value is None:
                        reveal(grid)
    
    if n == 0:
        return '\n'.join(' '.join(str(open(i, j)) for j in range(len(map[i]))) for i in range(len(map)))
    
    map = [row.split() for row in map.splitlines()]
    h, w = len(map), len(map[0])
    game = [[Grid(i, j) for j in range(w)] for i in range(h)]
    probe, moves = set(), set()
    
    for i,row in enumerate(game):
        for j,g in enumerate(row):
            if map[i][j] == "0":
                probe.add(g)
            for k in range(i-1, i+2):
                for l in range(j-1, j+2):
                    if (i != k or j != l) and 0 <= k < h and 0 <= l < w:
                        game[i][j].neighbors.add(game[k][l])
                        game[i][j].constraints.add(game[k][l])
    
    start()
    return n and "?" or '\n'.join(' '.join(row) for row in map)
###################################
import numpy as np
import queue
from itertools import permutations


class Minefield:
    def __init__(self, minefield, number_of_bombs):
        self.minefield, self.starting_positions = self.parse_map(minefield)
        self.n = number_of_bombs

    def solve(self):
        q = queue.Queue()
        [q.put(x) for x in self.starting_positions]
        maybe_stuck = 0

        while 1:

            if (self.n - self.bombs_found() <= 0 and len(self.question_marks()) == 0) or q.empty():

                if self.n - self.bombs_found() <= 0 and len(self.question_marks()) > 0:
                    for qm in self.question_marks():
                        qm.value = open(qm.y, qm.x)

                if self.n - self.bombs_found() == len(self.question_marks()):
                    if self.n - self.bombs_found() > 0:
                        for qm in self.question_marks():
                            qm.value = 'x'

                if self.solved():
                    return self.map_to_string()

                if maybe_stuck == 0:
                    # Put numbers adjacent to question marks in queue
                    qms = self.question_marks()
                    to_queue = set()
                    for qm in qms:
                        [to_queue.add(number) for number in qm.nearby_numbers()]
                        [q.put(x) for x in to_queue]
                    maybe_stuck = 1
                    continue
                else:
                    type, solution = self.solve_stuck()
                    if solution:
                        # print(solution)
                        # print('found a unique solution to this pickle')
                        if type == 'mines':
                            for bomb in solution:
                                bomb.value = 'x'
                        if type == 'safe':
                            for confirmed_safe in solution:
                                confirmed_safe.value = int(open(confirmed_safe.y, confirmed_safe.x))

                        # print(minefield.minefield)

                        qms = self.question_marks()
                        to_queue = set()
                        for qm in qms:
                            [to_queue.add(number) for number in qm.nearby_numbers()]
                            [q.put(x) for x in to_queue]
                        maybe_stuck = 0
                        continue

                    # print(f'stuck at ({len(minefield.question_marks())} question marks)')
                    # print(f'{n- minefield.bombs_found()} bombs remaining')
                    print(self.minefield)
                    return '?'

            box = q.get()
            unknowns = box.nearby_unknowns()
            bombs = box.nearby_bombs()

            # If all nearby bombs have been found, open everything else
            if len(unknowns) > 0 and box.value == len(bombs):
                for guy in unknowns:
                    guy.value = int(open(guy.y, guy.x))
                    q.put(guy)
                    maybe_stuck = 0

            unknowns = box.nearby_unknowns()
            bombs = box.nearby_bombs()
            # Find bombs
            if box.value == len(unknowns)+len(bombs):
                for guy in unknowns:
                    guy.value = 'x'
                    maybe_stuck = 0

    def solve_stuck(self, test_bombs=0):
        bombs_remaining = self.n - self.bombs_found()

        # Just a test parameter, ignore
        if test_bombs:
            bombs_remaining = test_bombs

        all_qms = self.question_marks()
        numbers = set()
        qms = set()
        for qm in all_qms:
            [numbers.add(number) for number in qm.nearby_numbers()]
        for number in numbers:
            [qms.add(qm) for qm in number.nearby_unknowns()]

        # Can change this if '?'s take too long
        if len(self.question_marks())*bombs_remaining > 100 and len(self.question_marks()) != len(qms):
            return None, False

        # picks 2 question marks at random to check if they could be it
        posibilities = []

        if len(all_qms) == len(qms):
            bomb_range = range(bombs_remaining, bombs_remaining+1)
        else:
            bomb_range = range(1, bombs_remaining+1)

        for bomb_amount in bomb_range:
            ps = permutations(list(qms), bomb_amount)
            posibilities += list(set([tuple(sorted(p)) for p in ps]))

        unique_solution = True
        solution = None

        possible_values = []

        for posibility in posibilities:
            # turn all cases to 'x'
            for bomb in posibility:
                bomb.value = 'x'

            # see if it's a valid solution
            for number in numbers:
                if number.value != number.n_nearby_bombs():

                    for bomb in posibility:
                        bomb.value = '?'
                    # print(f'{number.nearby_bombs()}')
                    # print(f'{number.value} at {number.y}, {number.x} wasnt satisfied')
                    break
            else:
                bad = False
                if len(posibility) == bombs_remaining:
                    for qm in self.question_marks():
                        if qm.n_nearby_bombs() == 0:
                            # print(f'empty spot at {qm.y}, {qm.x}')
                            bad = True

                else:
                    for qm in qms:
                        if qm.value != 'x':
                            if qm.n_nearby_bombs() == 0:
                                # print(f'empty spot at {qm.y}, {qm.x}')
                                bad = True

                if bad is False:
                    possible_values.append(posibility)
                    if solution:
                        for bomb in posibility:
                            bomb.value = '?'
                        unique_solution = False
                    if len(self.question_marks()) >= bombs_remaining:
                        solution = posibility

                for bomb in posibility:
                    bomb.value = '?'

        # PRINT POSSIBLE_VALUES:
        # print(possible_values)
        # print('Possible values at:')
        # for ps in possible_values:
        #     print(ps)
        #     for dimension in ps:
        #         print(f'{dimension.y}, {dimension.x}')
        # print('we see they all agree on 1,1, so its gotta be correct')
        # END PRINT POSSIBLE_VALUES
        # GET VALUE IN COMMON FROM POSSIBLE_VALUES
        cpv = common_possible_values(possible_values)
        if cpv == []:
            safe_cases = unseen_possible_values(possible_values, qms)
        # if we don't have a solution, we return cpv
        # print('cpv', cpv)
        # print(self.minefield)
        if solution and unique_solution is True:
            return ('mines', solution)
        elif cpv != []:
            return ('mines', cpv)
        else:
            return ('safe', safe_cases)

    def parse_map(self, gamefield):
        self.bombs_remaining = 0
        starting_positions = []
        minefield = np.array([x.split(' ') for x in gamefield.split('\n')],
                             dtype=np.object)

        for y, row in enumerate(minefield):
            for x, value in enumerate(row):
                minefield[y, x] = Node(y, x, value)
                if value != '?':
                    self.bombs_remaining += 1
                    starting_positions.append(minefield[y, x])

        for row in minefield:
            for node in row:
                node.get_paths(minefield)

        return minefield, starting_positions

    def map_to_string(self):
        rows = []
        for row in self.minefield:
            rows.append(' '.join([str(node.value) for node in row]))
        return '\n'.join(rows)

    def solved(self):
        for row in self.minefield:
            for node in row:
                if node.value == '?':
                    return False
        else:
            return True

    def question_marks(self):
        qs = []
        for row in self.minefield:
            for node in row:
                if node.value == '?':
                    qs.append(node)
        return qs

    def bombs_found(self):
        bs = []
        for row in self.minefield:
            for node in row:
                if node.value == 'x':
                    bs.append(node)
        return len(bs)


class Node:
    def __init__(self, y, x, value):
        self.y = y
        self.x = x
        # Turns numbers into ints and leaves question marks
        self.value = value if value == '?' or value == 'x' else int(value)

    def get_paths(self, minefield):
        self.paths = []
        height, width = minefield.shape

        if self.y > 0 and self.x > 0:
            self.paths.append(minefield[self.y-1, self.x-1])
        if self.y < height-1 and self.x > 0:
            self.paths.append(minefield[self.y+1, self.x-1])
        if self.x < width-1 and self.y > 0:
            self.paths.append(minefield[self.y-1, self.x+1])
        if self.x < width-1 and self.y < height-1:
            self.paths.append(minefield[self.y+1, self.x+1])

        if self.y > 0:
            self.paths.append(minefield[self.y-1, self.x])
        if self.y < height-1:
            self.paths.append(minefield[self.y+1, self.x])
        if self.x > 0:
            self.paths.append(minefield[self.y, self.x-1])
        if self.x < width-1:
            self.paths.append(minefield[self.y, self.x+1])

    def nearby_unknowns(self):
        return [box for box in self.paths if box.value == '?']

    def nearby_bombs(self):
        return [box for box in self.paths if box.value == 'x']

    def nearby_numbers(self):
        return [box for box in self.paths if isinstance(box.value, int)]

    def n_nearby_unknowns(self):
        return sum(1 for box in self.paths if box.value == '?')

    def n_nearby_bombs(self):
        return sum(1 for box in self.paths if box.value == 'x')

    def n_nearby_numbers(self):
        return sum(1 for box in self.paths if isinstance(box.value, int))

    def __repr__(self):
        return str(self.value)

    def __gt__(self, other):
        return id(self) > id(other)


def common_possible_values(possible_values):

    values = set()
    for guy in possible_values:
        for ps in guy:
            values.add(ps)

    values = list(values)
    common_values = []

    for value in values:
        for every_one in possible_values:
            if value not in every_one:
                break
        else:
            common_values.append(value)
    
    return common_values


def unseen_possible_values(possible_values, unknowns):
    qms = list(unknowns)
    values = set()
    for guy in possible_values:
        for ps in guy:
            values.add(ps)

    values = list(values)
    unseen_values = []
    # print(values)
    # print(qms)

    for qm in qms:
        if qm not in values:
            unseen_values.append(qm)

    return unseen_values


def solve_mine(mapa, n):
    minefield = Minefield(mapa, n)
    return minefield.solve()

# TESTING


s = '''
1 ? ?
2 ? ?
x 2 1
'''.strip()
# this one has 3 bombs V
s = '''
1 2 x 1
? ? 2 1
? ? 2 1
? ? 2 x
? ? ? 2
? ? ? 1
'''.strip()
s = '''
x 2 1
2 ? ?
1 ? ?
2 ? ?
2 ? ?
2 ? ?
'''.strip()
s = '''
1 2 2 1 0 0
2 x x 2 1 1
2 3 ? ? ? ?
1 1 ? ? ? ?
'''.strip()
s = '''
x 2 x 2 x 1 1 x 2 1
1 2 1 2 1 1 1 2 ? ?
0 0 1 1 1 0 0 1 ? ?
0 0 1 x 1 1 1 2 ? ?
0 0 1 1 1 1 x 2 ? ?
0 0 0 0 0 1 1 2 ? ?
'''.strip()
# s = '''
# 1 ? 1 0 0 1 ? 1
# 2 ? 2 2 2 3 ? 2
# x 3 ? ? ? ? ? 1
# 1 2 ? ? ? ? ? 2
# 0 1 ? ? ? ? ? 1
# '''.strip()
s = '''
x 1 ?
? ? ?
? ? ?
'''.strip()

# Testing for advanced situations:

# minefield = Minefield(s)
# test = stuck_solver(minefield, 2, test=True)
# if test[1]:
#     if test[0] == 'safe':
#         print(f'Found safe square(s) at:')
#     if test[0] == 'mines':
#         print(f'Found mine(s) at:')
#     [print(f'({case.y}, {case.x})') for case in test[1]]
# else:
