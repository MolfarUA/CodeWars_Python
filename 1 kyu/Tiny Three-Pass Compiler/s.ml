5265b0885fda8eac5900093b



let tokenize code =
  let rec explode string =
    if String.length string = 0 then []
    else [String.sub string 0 1] @
           explode (String.sub string 1 ((String.length string) - 1))
  in
  let specialChars =
    [
      "["; "]"; "-"; "+"; "*"; "/"; "("; ")"
    ]
  in
  let nonSpecialHelper = function
    | "" -> []
    | str -> [str]
  in
  let rec tokenizeHelper = function
    | [],currentItem, tokens ->
       tokens @ (nonSpecialHelper currentItem)
    | " "::lst, currentItem, tokens ->
       tokenizeHelper(
           lst,"",
           tokens @ nonSpecialHelper currentItem)
    | item::lst, currentItem, tokens ->
       if List.mem item specialChars then
         tokenizeHelper(
             lst, "",
             tokens @ nonSpecialHelper currentItem @ [item])
       else
         tokenizeHelper(lst, currentItem ^ item,tokens)
  in
  tokenizeHelper(explode code, "", [])
(* Parsing *)


module Parser = struct
(* Generated by Menhir on the following input:
%{
type parsed_ast =
  | PArg of string
  | PImm of int
  | PAdd of parsed_ast * parsed_ast
  | PMul of parsed_ast * parsed_ast
  | PSub of parsed_ast * parsed_ast
  | PDiv of parsed_ast * parsed_ast
            %}

%token LEFT_BRACKET RIGHT_BRACKET LEFT_PAREN RIGHT_PAREN ADD MUL SUB DIV EOF
%token <string> ARG
%token <int> IMM
%start <string list * parsed_ast> func

%%

func : LEFT_BRACKET arglist RIGHT_BRACKET expression EOF { ($2, $4) };

arglist    : /* nothing */                     { [] }
           | ARG arglist                       { $1 :: $2 }
;

expression : term { $1 }
           | expression ADD term               { PAdd ($1, $3) }
           | expression SUB term               { PSub ($1, $3) }
;

term       : factor                            { $1 }
           | term MUL factor                   { PMul ($1, $3) }
           | term DIV factor                   { PDiv ($1, $3) }
;

factor     : IMM                               { PImm $1 }
           | ARG                               { PArg $1 }
           | LEFT_PAREN expression RIGHT_PAREN { $2 }
;

%%
 *)


module MenhirBasics = struct
  
  exception Error
  
  type token = 
    | SUB
    | RIGHT_PAREN
    | RIGHT_BRACKET
    | MUL
    | LEFT_PAREN
    | LEFT_BRACKET
    | IMM of (
# 13 "compiler_parser.mly"
       (int)
# 17 "compiler_parser.ml"
  )
    | EOF
    | DIV
    | ARG of (
# 12 "compiler_parser.mly"
       (string)
# 24 "compiler_parser.ml"
  )
    | ADD
  
end

include MenhirBasics

let _eRR =
  MenhirBasics.Error

type _menhir_env = {
  _menhir_lexer: Lexing.lexbuf -> token;
  _menhir_lexbuf: Lexing.lexbuf;
  _menhir_token: token;
  mutable _menhir_error: bool
}

and _menhir_state = 
  | MenhirState19
  | MenhirState16
  | MenhirState12
  | MenhirState10
  | MenhirState6
  | MenhirState5
  | MenhirState2
  | MenhirState1

# 1 "compiler_parser.mly"
  
type parsed_ast =
  | PArg of string
  | PImm of int
  | PAdd of parsed_ast * parsed_ast
  | PMul of parsed_ast * parsed_ast
  | PSub of parsed_ast * parsed_ast
  | PDiv of parsed_ast * parsed_ast
            
# 62 "compiler_parser.ml"

let rec _menhir_run16 : _menhir_env -> 'ttv_tail * _menhir_state * 'tv_expression -> 'ttv_return =
  fun _menhir_env _menhir_stack ->
    let _menhir_env = _menhir_discard _menhir_env in
    let _tok = _menhir_env._menhir_token in
    match _tok with
    | ARG _v ->
        _menhir_run8 _menhir_env (Obj.magic _menhir_stack) MenhirState16 _v
    | IMM _v ->
        _menhir_run7 _menhir_env (Obj.magic _menhir_stack) MenhirState16 _v
    | LEFT_PAREN ->
        _menhir_run6 _menhir_env (Obj.magic _menhir_stack) MenhirState16
    | _ ->
        assert (not _menhir_env._menhir_error);
        _menhir_env._menhir_error <- true;
        _menhir_errorcase _menhir_env (Obj.magic _menhir_stack) MenhirState16

and _menhir_run19 : _menhir_env -> 'ttv_tail * _menhir_state * 'tv_expression -> 'ttv_return =
  fun _menhir_env _menhir_stack ->
    let _menhir_env = _menhir_discard _menhir_env in
    let _tok = _menhir_env._menhir_token in
    match _tok with
    | ARG _v ->
        _menhir_run8 _menhir_env (Obj.magic _menhir_stack) MenhirState19 _v
    | IMM _v ->
        _menhir_run7 _menhir_env (Obj.magic _menhir_stack) MenhirState19 _v
    | LEFT_PAREN ->
        _menhir_run6 _menhir_env (Obj.magic _menhir_stack) MenhirState19
    | _ ->
        assert (not _menhir_env._menhir_error);
        _menhir_env._menhir_error <- true;
        _menhir_errorcase _menhir_env (Obj.magic _menhir_stack) MenhirState19

and _menhir_goto_expression : _menhir_env -> 'ttv_tail -> _menhir_state -> 'tv_expression -> 'ttv_return =
  fun _menhir_env _menhir_stack _menhir_s _v ->
    let _menhir_stack = (_menhir_stack, _menhir_s, _v) in
    match _menhir_s with
    | MenhirState6 ->
        let (_menhir_env : _menhir_env) = _menhir_env in
        let (_menhir_stack : ('freshtv73 * _menhir_state) * _menhir_state * 'tv_expression) = Obj.magic _menhir_stack in
        ((assert (not _menhir_env._menhir_error);
        let _tok = _menhir_env._menhir_token in
        match _tok with
        | ADD ->
            _menhir_run19 _menhir_env (Obj.magic _menhir_stack)
        | RIGHT_PAREN ->
            let (_menhir_env : _menhir_env) = _menhir_env in
            let (_menhir_stack : ('freshtv69 * _menhir_state) * _menhir_state * 'tv_expression) = Obj.magic _menhir_stack in
            ((let _menhir_env = _menhir_discard _menhir_env in
            let (_menhir_env : _menhir_env) = _menhir_env in
            let (_menhir_stack : ('freshtv67 * _menhir_state) * _menhir_state * 'tv_expression) = Obj.magic _menhir_stack in
            ((let ((_menhir_stack, _menhir_s), _, (_2 : 'tv_expression)) = _menhir_stack in
            let _3 = () in
            let _1 = () in
            let _v : 'tv_factor = 
# 36 "compiler_parser.mly"
                                               ( _2 )
# 120 "compiler_parser.ml"
             in
            _menhir_goto_factor _menhir_env _menhir_stack _menhir_s _v) : 'freshtv68)) : 'freshtv70)
        | SUB ->
            _menhir_run16 _menhir_env (Obj.magic _menhir_stack)
        | _ ->
            assert (not _menhir_env._menhir_error);
            _menhir_env._menhir_error <- true;
            let (_menhir_env : _menhir_env) = _menhir_env in
            let (_menhir_stack : ('freshtv71 * _menhir_state) * _menhir_state * 'tv_expression) = Obj.magic _menhir_stack in
            ((let (_menhir_stack, _menhir_s, _) = _menhir_stack in
            _menhir_errorcase _menhir_env (Obj.magic _menhir_stack) _menhir_s) : 'freshtv72)) : 'freshtv74)
    | MenhirState5 ->
        let (_menhir_env : _menhir_env) = _menhir_env in
        let (_menhir_stack : ((('freshtv87) * _menhir_state * 'tv_arglist)) * _menhir_state * 'tv_expression) = Obj.magic _menhir_stack in
        ((assert (not _menhir_env._menhir_error);
        let _tok = _menhir_env._menhir_token in
        match _tok with
        | ADD ->
            _menhir_run19 _menhir_env (Obj.magic _menhir_stack)
        | EOF ->
            let (_menhir_env : _menhir_env) = _menhir_env in
            let (_menhir_stack : ((('freshtv83) * _menhir_state * 'tv_arglist)) * _menhir_state * 'tv_expression) = Obj.magic _menhir_stack in
            ((let (_menhir_env : _menhir_env) = _menhir_env in
            let (_menhir_stack : ((('freshtv81) * _menhir_state * 'tv_arglist)) * _menhir_state * 'tv_expression) = Obj.magic _menhir_stack in
            ((let ((_menhir_stack, _, (_2 : 'tv_arglist)), _, (_4 : 'tv_expression)) = _menhir_stack in
            let _5 = () in
            let _3 = () in
            let _1 = () in
            let _v : (
# 14 "compiler_parser.mly"
       (string list * parsed_ast)
# 152 "compiler_parser.ml"
            ) = 
# 18 "compiler_parser.mly"
                                                         ( (_2, _4) )
# 156 "compiler_parser.ml"
             in
            let (_menhir_env : _menhir_env) = _menhir_env in
            let (_menhir_stack : 'freshtv79) = _menhir_stack in
            let (_v : (
# 14 "compiler_parser.mly"
       (string list * parsed_ast)
# 163 "compiler_parser.ml"
            )) = _v in
            ((let (_menhir_env : _menhir_env) = _menhir_env in
            let (_menhir_stack : 'freshtv77) = Obj.magic _menhir_stack in
            let (_v : (
# 14 "compiler_parser.mly"
       (string list * parsed_ast)
# 170 "compiler_parser.ml"
            )) = _v in
            ((let (_menhir_env : _menhir_env) = _menhir_env in
            let (_menhir_stack : 'freshtv75) = Obj.magic _menhir_stack in
            let ((_1 : (
# 14 "compiler_parser.mly"
       (string list * parsed_ast)
# 177 "compiler_parser.ml"
            )) : (
# 14 "compiler_parser.mly"
       (string list * parsed_ast)
# 181 "compiler_parser.ml"
            )) = _v in
            (Obj.magic _1 : 'freshtv76)) : 'freshtv78)) : 'freshtv80)) : 'freshtv82)) : 'freshtv84)
        | SUB ->
            _menhir_run16 _menhir_env (Obj.magic _menhir_stack)
        | _ ->
            assert (not _menhir_env._menhir_error);
            _menhir_env._menhir_error <- true;
            let (_menhir_env : _menhir_env) = _menhir_env in
            let (_menhir_stack : ((('freshtv85) * _menhir_state * 'tv_arglist)) * _menhir_state * 'tv_expression) = Obj.magic _menhir_stack in
            ((let (_menhir_stack, _menhir_s, _) = _menhir_stack in
            _menhir_errorcase _menhir_env (Obj.magic _menhir_stack) _menhir_s) : 'freshtv86)) : 'freshtv88)
    | _ ->
        _menhir_fail ()

and _menhir_run10 : _menhir_env -> 'ttv_tail * _menhir_state * 'tv_term -> 'ttv_return =
  fun _menhir_env _menhir_stack ->
    let _menhir_env = _menhir_discard _menhir_env in
    let _tok = _menhir_env._menhir_token in
    match _tok with
    | ARG _v ->
        _menhir_run8 _menhir_env (Obj.magic _menhir_stack) MenhirState10 _v
    | IMM _v ->
        _menhir_run7 _menhir_env (Obj.magic _menhir_stack) MenhirState10 _v
    | LEFT_PAREN ->
        _menhir_run6 _menhir_env (Obj.magic _menhir_stack) MenhirState10
    | _ ->
        assert (not _menhir_env._menhir_error);
        _menhir_env._menhir_error <- true;
        _menhir_errorcase _menhir_env (Obj.magic _menhir_stack) MenhirState10

and _menhir_run12 : _menhir_env -> 'ttv_tail * _menhir_state * 'tv_term -> 'ttv_return =
  fun _menhir_env _menhir_stack ->
    let _menhir_env = _menhir_discard _menhir_env in
    let _tok = _menhir_env._menhir_token in
    match _tok with
    | ARG _v ->
        _menhir_run8 _menhir_env (Obj.magic _menhir_stack) MenhirState12 _v
    | IMM _v ->
        _menhir_run7 _menhir_env (Obj.magic _menhir_stack) MenhirState12 _v
    | LEFT_PAREN ->
        _menhir_run6 _menhir_env (Obj.magic _menhir_stack) MenhirState12
    | _ ->
        assert (not _menhir_env._menhir_error);
        _menhir_env._menhir_error <- true;
        _menhir_errorcase _menhir_env (Obj.magic _menhir_stack) MenhirState12

and _menhir_goto_term : _menhir_env -> 'ttv_tail -> _menhir_state -> 'tv_term -> 'ttv_return =
  fun _menhir_env _menhir_stack _menhir_s _v ->
    let _menhir_stack = (_menhir_stack, _menhir_s, _v) in
    match _menhir_s with
    | MenhirState5 | MenhirState6 ->
        let (_menhir_env : _menhir_env) = _menhir_env in
        let (_menhir_stack : 'freshtv53 * _menhir_state * 'tv_term) = Obj.magic _menhir_stack in
        ((assert (not _menhir_env._menhir_error);
        let _tok = _menhir_env._menhir_token in
        match _tok with
        | DIV ->
            _menhir_run12 _menhir_env (Obj.magic _menhir_stack)
        | MUL ->
            _menhir_run10 _menhir_env (Obj.magic _menhir_stack)
        | ADD | EOF | RIGHT_PAREN | SUB ->
            let (_menhir_env : _menhir_env) = _menhir_env in
            let (_menhir_stack : 'freshtv49 * _menhir_state * 'tv_term) = Obj.magic _menhir_stack in
            ((let (_menhir_stack, _menhir_s, (_1 : 'tv_term)) = _menhir_stack in
            let _v : 'tv_expression = 
# 24 "compiler_parser.mly"
                  ( _1 )
# 249 "compiler_parser.ml"
             in
            _menhir_goto_expression _menhir_env _menhir_stack _menhir_s _v) : 'freshtv50)
        | _ ->
            assert (not _menhir_env._menhir_error);
            _menhir_env._menhir_error <- true;
            let (_menhir_env : _menhir_env) = _menhir_env in
            let (_menhir_stack : 'freshtv51 * _menhir_state * 'tv_term) = Obj.magic _menhir_stack in
            ((let (_menhir_stack, _menhir_s, _) = _menhir_stack in
            _menhir_errorcase _menhir_env (Obj.magic _menhir_stack) _menhir_s) : 'freshtv52)) : 'freshtv54)
    | MenhirState16 ->
        let (_menhir_env : _menhir_env) = _menhir_env in
        let (_menhir_stack : (('freshtv59 * _menhir_state * 'tv_expression)) * _menhir_state * 'tv_term) = Obj.magic _menhir_stack in
        ((assert (not _menhir_env._menhir_error);
        let _tok = _menhir_env._menhir_token in
        match _tok with
        | DIV ->
            _menhir_run12 _menhir_env (Obj.magic _menhir_stack)
        | MUL ->
            _menhir_run10 _menhir_env (Obj.magic _menhir_stack)
        | ADD | EOF | RIGHT_PAREN | SUB ->
            let (_menhir_env : _menhir_env) = _menhir_env in
            let (_menhir_stack : (('freshtv55 * _menhir_state * 'tv_expression)) * _menhir_state * 'tv_term) = Obj.magic _menhir_stack in
            ((let ((_menhir_stack, _menhir_s, (_1 : 'tv_expression)), _, (_3 : 'tv_term)) = _menhir_stack in
            let _2 = () in
            let _v : 'tv_expression = 
# 26 "compiler_parser.mly"
                                               ( PSub (_1, _3) )
# 277 "compiler_parser.ml"
             in
            _menhir_goto_expression _menhir_env _menhir_stack _menhir_s _v) : 'freshtv56)
        | _ ->
            assert (not _menhir_env._menhir_error);
            _menhir_env._menhir_error <- true;
            let (_menhir_env : _menhir_env) = _menhir_env in
            let (_menhir_stack : (('freshtv57 * _menhir_state * 'tv_expression)) * _menhir_state * 'tv_term) = Obj.magic _menhir_stack in
            ((let (_menhir_stack, _menhir_s, _) = _menhir_stack in
            _menhir_errorcase _menhir_env (Obj.magic _menhir_stack) _menhir_s) : 'freshtv58)) : 'freshtv60)
    | MenhirState19 ->
        let (_menhir_env : _menhir_env) = _menhir_env in
        let (_menhir_stack : (('freshtv65 * _menhir_state * 'tv_expression)) * _menhir_state * 'tv_term) = Obj.magic _menhir_stack in
        ((assert (not _menhir_env._menhir_error);
        let _tok = _menhir_env._menhir_token in
        match _tok with
        | DIV ->
            _menhir_run12 _menhir_env (Obj.magic _menhir_stack)
        | MUL ->
            _menhir_run10 _menhir_env (Obj.magic _menhir_stack)
        | ADD | EOF | RIGHT_PAREN | SUB ->
            let (_menhir_env : _menhir_env) = _menhir_env in
            let (_menhir_stack : (('freshtv61 * _menhir_state * 'tv_expression)) * _menhir_state * 'tv_term) = Obj.magic _menhir_stack in
            ((let ((_menhir_stack, _menhir_s, (_1 : 'tv_expression)), _, (_3 : 'tv_term)) = _menhir_stack in
            let _2 = () in
            let _v : 'tv_expression = 
# 25 "compiler_parser.mly"
                                               ( PAdd (_1, _3) )
# 305 "compiler_parser.ml"
             in
            _menhir_goto_expression _menhir_env _menhir_stack _menhir_s _v) : 'freshtv62)
        | _ ->
            assert (not _menhir_env._menhir_error);
            _menhir_env._menhir_error <- true;
            let (_menhir_env : _menhir_env) = _menhir_env in
            let (_menhir_stack : (('freshtv63 * _menhir_state * 'tv_expression)) * _menhir_state * 'tv_term) = Obj.magic _menhir_stack in
            ((let (_menhir_stack, _menhir_s, _) = _menhir_stack in
            _menhir_errorcase _menhir_env (Obj.magic _menhir_stack) _menhir_s) : 'freshtv64)) : 'freshtv66)
    | _ ->
        _menhir_fail ()

and _menhir_goto_factor : _menhir_env -> 'ttv_tail -> _menhir_state -> 'tv_factor -> 'ttv_return =
  fun _menhir_env _menhir_stack _menhir_s _v ->
    match _menhir_s with
    | MenhirState10 ->
        let (_menhir_env : _menhir_env) = _menhir_env in
        let (_menhir_stack : ('freshtv39 * _menhir_state * 'tv_term)) = Obj.magic _menhir_stack in
        let (_menhir_s : _menhir_state) = _menhir_s in
        let (_v : 'tv_factor) = _v in
        ((let (_menhir_env : _menhir_env) = _menhir_env in
        let (_menhir_stack : ('freshtv37 * _menhir_state * 'tv_term)) = Obj.magic _menhir_stack in
        let (_ : _menhir_state) = _menhir_s in
        let ((_3 : 'tv_factor) : 'tv_factor) = _v in
        ((let (_menhir_stack, _menhir_s, (_1 : 'tv_term)) = _menhir_stack in
        let _2 = () in
        let _v : 'tv_term = 
# 30 "compiler_parser.mly"
                                               ( PMul (_1, _3) )
# 335 "compiler_parser.ml"
         in
        _menhir_goto_term _menhir_env _menhir_stack _menhir_s _v) : 'freshtv38)) : 'freshtv40)
    | MenhirState12 ->
        let (_menhir_env : _menhir_env) = _menhir_env in
        let (_menhir_stack : ('freshtv43 * _menhir_state * 'tv_term)) = Obj.magic _menhir_stack in
        let (_menhir_s : _menhir_state) = _menhir_s in
        let (_v : 'tv_factor) = _v in
        ((let (_menhir_env : _menhir_env) = _menhir_env in
        let (_menhir_stack : ('freshtv41 * _menhir_state * 'tv_term)) = Obj.magic _menhir_stack in
        let (_ : _menhir_state) = _menhir_s in
        let ((_3 : 'tv_factor) : 'tv_factor) = _v in
        ((let (_menhir_stack, _menhir_s, (_1 : 'tv_term)) = _menhir_stack in
        let _2 = () in
        let _v : 'tv_term = 
# 31 "compiler_parser.mly"
                                               ( PDiv (_1, _3) )
# 352 "compiler_parser.ml"
         in
        _menhir_goto_term _menhir_env _menhir_stack _menhir_s _v) : 'freshtv42)) : 'freshtv44)
    | MenhirState5 | MenhirState19 | MenhirState16 | MenhirState6 ->
        let (_menhir_env : _menhir_env) = _menhir_env in
        let (_menhir_stack : 'freshtv47) = Obj.magic _menhir_stack in
        let (_menhir_s : _menhir_state) = _menhir_s in
        let (_v : 'tv_factor) = _v in
        ((let (_menhir_env : _menhir_env) = _menhir_env in
        let (_menhir_stack : 'freshtv45) = Obj.magic _menhir_stack in
        let (_menhir_s : _menhir_state) = _menhir_s in
        let ((_1 : 'tv_factor) : 'tv_factor) = _v in
        ((let _v : 'tv_term = 
# 29 "compiler_parser.mly"
                                               ( _1 )
# 367 "compiler_parser.ml"
         in
        _menhir_goto_term _menhir_env _menhir_stack _menhir_s _v) : 'freshtv46)) : 'freshtv48)
    | _ ->
        _menhir_fail ()

and _menhir_fail : unit -> 'a =
  fun () ->
    Printf.fprintf stderr "Internal failure -- please contact the parser generator's developers.\n%!";
    assert false

and _menhir_run6 : _menhir_env -> 'ttv_tail -> _menhir_state -> 'ttv_return =
  fun _menhir_env _menhir_stack _menhir_s ->
    let _menhir_stack = (_menhir_stack, _menhir_s) in
    let _menhir_env = _menhir_discard _menhir_env in
    let _tok = _menhir_env._menhir_token in
    match _tok with
    | ARG _v ->
        _menhir_run8 _menhir_env (Obj.magic _menhir_stack) MenhirState6 _v
    | IMM _v ->
        _menhir_run7 _menhir_env (Obj.magic _menhir_stack) MenhirState6 _v
    | LEFT_PAREN ->
        _menhir_run6 _menhir_env (Obj.magic _menhir_stack) MenhirState6
    | _ ->
        assert (not _menhir_env._menhir_error);
        _menhir_env._menhir_error <- true;
        _menhir_errorcase _menhir_env (Obj.magic _menhir_stack) MenhirState6

and _menhir_run7 : _menhir_env -> 'ttv_tail -> _menhir_state -> (
# 13 "compiler_parser.mly"
       (int)
# 398 "compiler_parser.ml"
) -> 'ttv_return =
  fun _menhir_env _menhir_stack _menhir_s _v ->
    let _menhir_env = _menhir_discard _menhir_env in
    let (_menhir_env : _menhir_env) = _menhir_env in
    let (_menhir_stack : 'freshtv35) = Obj.magic _menhir_stack in
    let (_menhir_s : _menhir_state) = _menhir_s in
    let ((_1 : (
# 13 "compiler_parser.mly"
       (int)
# 408 "compiler_parser.ml"
    )) : (
# 13 "compiler_parser.mly"
       (int)
# 412 "compiler_parser.ml"
    )) = _v in
    ((let _v : 'tv_factor = 
# 34 "compiler_parser.mly"
                                               ( PImm _1 )
# 417 "compiler_parser.ml"
     in
    _menhir_goto_factor _menhir_env _menhir_stack _menhir_s _v) : 'freshtv36)

and _menhir_run8 : _menhir_env -> 'ttv_tail -> _menhir_state -> (
# 12 "compiler_parser.mly"
       (string)
# 424 "compiler_parser.ml"
) -> 'ttv_return =
  fun _menhir_env _menhir_stack _menhir_s _v ->
    let _menhir_env = _menhir_discard _menhir_env in
    let (_menhir_env : _menhir_env) = _menhir_env in
    let (_menhir_stack : 'freshtv33) = Obj.magic _menhir_stack in
    let (_menhir_s : _menhir_state) = _menhir_s in
    let ((_1 : (
# 12 "compiler_parser.mly"
       (string)
# 434 "compiler_parser.ml"
    )) : (
# 12 "compiler_parser.mly"
       (string)
# 438 "compiler_parser.ml"
    )) = _v in
    ((let _v : 'tv_factor = 
# 35 "compiler_parser.mly"
                                               ( PArg _1 )
# 443 "compiler_parser.ml"
     in
    _menhir_goto_factor _menhir_env _menhir_stack _menhir_s _v) : 'freshtv34)

and _menhir_goto_arglist : _menhir_env -> 'ttv_tail -> _menhir_state -> 'tv_arglist -> 'ttv_return =
  fun _menhir_env _menhir_stack _menhir_s _v ->
    let _menhir_stack = (_menhir_stack, _menhir_s, _v) in
    match _menhir_s with
    | MenhirState2 ->
        let (_menhir_env : _menhir_env) = _menhir_env in
        let (_menhir_stack : ('freshtv25 * _menhir_state * (
# 12 "compiler_parser.mly"
       (string)
# 456 "compiler_parser.ml"
        )) * _menhir_state * 'tv_arglist) = Obj.magic _menhir_stack in
        ((let (_menhir_env : _menhir_env) = _menhir_env in
        let (_menhir_stack : ('freshtv23 * _menhir_state * (
# 12 "compiler_parser.mly"
       (string)
# 462 "compiler_parser.ml"
        )) * _menhir_state * 'tv_arglist) = Obj.magic _menhir_stack in
        ((let ((_menhir_stack, _menhir_s, (_1 : (
# 12 "compiler_parser.mly"
       (string)
# 467 "compiler_parser.ml"
        ))), _, (_2 : 'tv_arglist)) = _menhir_stack in
        let _v : 'tv_arglist = 
# 21 "compiler_parser.mly"
                                               ( _1 :: _2 )
# 472 "compiler_parser.ml"
         in
        _menhir_goto_arglist _menhir_env _menhir_stack _menhir_s _v) : 'freshtv24)) : 'freshtv26)
    | MenhirState1 ->
        let (_menhir_env : _menhir_env) = _menhir_env in
        let (_menhir_stack : ('freshtv31) * _menhir_state * 'tv_arglist) = Obj.magic _menhir_stack in
        ((assert (not _menhir_env._menhir_error);
        let _tok = _menhir_env._menhir_token in
        match _tok with
        | RIGHT_BRACKET ->
            let (_menhir_env : _menhir_env) = _menhir_env in
            let (_menhir_stack : ('freshtv27) * _menhir_state * 'tv_arglist) = Obj.magic _menhir_stack in
            ((let _menhir_env = _menhir_discard _menhir_env in
            let _tok = _menhir_env._menhir_token in
            match _tok with
            | ARG _v ->
                _menhir_run8 _menhir_env (Obj.magic _menhir_stack) MenhirState5 _v
            | IMM _v ->
                _menhir_run7 _menhir_env (Obj.magic _menhir_stack) MenhirState5 _v
            | LEFT_PAREN ->
                _menhir_run6 _menhir_env (Obj.magic _menhir_stack) MenhirState5
            | _ ->
                assert (not _menhir_env._menhir_error);
                _menhir_env._menhir_error <- true;
                _menhir_errorcase _menhir_env (Obj.magic _menhir_stack) MenhirState5) : 'freshtv28)
        | _ ->
            assert (not _menhir_env._menhir_error);
            _menhir_env._menhir_error <- true;
            let (_menhir_env : _menhir_env) = _menhir_env in
            let (_menhir_stack : ('freshtv29) * _menhir_state * 'tv_arglist) = Obj.magic _menhir_stack in
            ((let (_menhir_stack, _menhir_s, _) = _menhir_stack in
            _menhir_errorcase _menhir_env (Obj.magic _menhir_stack) _menhir_s) : 'freshtv30)) : 'freshtv32)
    | _ ->
        _menhir_fail ()

and _menhir_errorcase : _menhir_env -> 'ttv_tail -> _menhir_state -> 'ttv_return =
  fun _menhir_env _menhir_stack _menhir_s ->
    match _menhir_s with
    | MenhirState19 ->
        let (_menhir_env : _menhir_env) = _menhir_env in
        let (_menhir_stack : ('freshtv7 * _menhir_state * 'tv_expression)) = Obj.magic _menhir_stack in
        ((let (_menhir_stack, _menhir_s, _) = _menhir_stack in
        _menhir_errorcase _menhir_env (Obj.magic _menhir_stack) _menhir_s) : 'freshtv8)
    | MenhirState16 ->
        let (_menhir_env : _menhir_env) = _menhir_env in
        let (_menhir_stack : ('freshtv9 * _menhir_state * 'tv_expression)) = Obj.magic _menhir_stack in
        ((let (_menhir_stack, _menhir_s, _) = _menhir_stack in
        _menhir_errorcase _menhir_env (Obj.magic _menhir_stack) _menhir_s) : 'freshtv10)
    | MenhirState12 ->
        let (_menhir_env : _menhir_env) = _menhir_env in
        let (_menhir_stack : ('freshtv11 * _menhir_state * 'tv_term)) = Obj.magic _menhir_stack in
        ((let (_menhir_stack, _menhir_s, _) = _menhir_stack in
        _menhir_errorcase _menhir_env (Obj.magic _menhir_stack) _menhir_s) : 'freshtv12)
    | MenhirState10 ->
        let (_menhir_env : _menhir_env) = _menhir_env in
        let (_menhir_stack : ('freshtv13 * _menhir_state * 'tv_term)) = Obj.magic _menhir_stack in
        ((let (_menhir_stack, _menhir_s, _) = _menhir_stack in
        _menhir_errorcase _menhir_env (Obj.magic _menhir_stack) _menhir_s) : 'freshtv14)
    | MenhirState6 ->
        let (_menhir_env : _menhir_env) = _menhir_env in
        let (_menhir_stack : 'freshtv15 * _menhir_state) = Obj.magic _menhir_stack in
        ((let (_menhir_stack, _menhir_s) = _menhir_stack in
        _menhir_errorcase _menhir_env (Obj.magic _menhir_stack) _menhir_s) : 'freshtv16)
    | MenhirState5 ->
        let (_menhir_env : _menhir_env) = _menhir_env in
        let (_menhir_stack : (('freshtv17) * _menhir_state * 'tv_arglist)) = Obj.magic _menhir_stack in
        ((let (_menhir_stack, _menhir_s, _) = _menhir_stack in
        _menhir_errorcase _menhir_env (Obj.magic _menhir_stack) _menhir_s) : 'freshtv18)
    | MenhirState2 ->
        let (_menhir_env : _menhir_env) = _menhir_env in
        let (_menhir_stack : 'freshtv19 * _menhir_state * (
# 12 "compiler_parser.mly"
       (string)
# 545 "compiler_parser.ml"
        )) = Obj.magic _menhir_stack in
        ((let (_menhir_stack, _menhir_s, _) = _menhir_stack in
        _menhir_errorcase _menhir_env (Obj.magic _menhir_stack) _menhir_s) : 'freshtv20)
    | MenhirState1 ->
        let (_menhir_env : _menhir_env) = _menhir_env in
        let (_menhir_stack : 'freshtv21) = Obj.magic _menhir_stack in
        (raise _eRR : 'freshtv22)

and _menhir_reduce1 : _menhir_env -> 'ttv_tail -> _menhir_state -> 'ttv_return =
  fun _menhir_env _menhir_stack _menhir_s ->
    let _v : 'tv_arglist = 
# 20 "compiler_parser.mly"
                                               ( [] )
# 559 "compiler_parser.ml"
     in
    _menhir_goto_arglist _menhir_env _menhir_stack _menhir_s _v

and _menhir_run2 : _menhir_env -> 'ttv_tail -> _menhir_state -> (
# 12 "compiler_parser.mly"
       (string)
# 566 "compiler_parser.ml"
) -> 'ttv_return =
  fun _menhir_env _menhir_stack _menhir_s _v ->
    let _menhir_stack = (_menhir_stack, _menhir_s, _v) in
    let _menhir_env = _menhir_discard _menhir_env in
    let _tok = _menhir_env._menhir_token in
    match _tok with
    | ARG _v ->
        _menhir_run2 _menhir_env (Obj.magic _menhir_stack) MenhirState2 _v
    | RIGHT_BRACKET ->
        _menhir_reduce1 _menhir_env (Obj.magic _menhir_stack) MenhirState2
    | _ ->
        assert (not _menhir_env._menhir_error);
        _menhir_env._menhir_error <- true;
        _menhir_errorcase _menhir_env (Obj.magic _menhir_stack) MenhirState2

and _menhir_discard : _menhir_env -> _menhir_env =
  fun _menhir_env ->
    let lexer = _menhir_env._menhir_lexer in
    let lexbuf = _menhir_env._menhir_lexbuf in
    let _tok = lexer lexbuf in
    {
      _menhir_lexer = lexer;
      _menhir_lexbuf = lexbuf;
      _menhir_token = _tok;
      _menhir_error = false;
    }

and func : (Lexing.lexbuf -> token) -> Lexing.lexbuf -> (
# 14 "compiler_parser.mly"
       (string list * parsed_ast)
# 597 "compiler_parser.ml"
) =
  fun lexer lexbuf ->
    let _menhir_env =
      let (lexer : Lexing.lexbuf -> token) = lexer in
      let (lexbuf : Lexing.lexbuf) = lexbuf in
      ((let _tok = Obj.magic () in
      {
        _menhir_lexer = lexer;
        _menhir_lexbuf = lexbuf;
        _menhir_token = _tok;
        _menhir_error = false;
      }) : _menhir_env)
    in
    Obj.magic (let (_menhir_env : _menhir_env) = _menhir_env in
    let (_menhir_stack : 'freshtv5) = ((), _menhir_env._menhir_lexbuf.Lexing.lex_curr_p) in
    ((let _menhir_env = _menhir_discard _menhir_env in
    let _tok = _menhir_env._menhir_token in
    match _tok with
    | LEFT_BRACKET ->
        let (_menhir_env : _menhir_env) = _menhir_env in
        let (_menhir_stack : 'freshtv1) = Obj.magic _menhir_stack in
        ((let _menhir_env = _menhir_discard _menhir_env in
        let _tok = _menhir_env._menhir_token in
        match _tok with
        | ARG _v ->
            _menhir_run2 _menhir_env (Obj.magic _menhir_stack) MenhirState1 _v
        | RIGHT_BRACKET ->
            _menhir_reduce1 _menhir_env (Obj.magic _menhir_stack) MenhirState1
        | _ ->
            assert (not _menhir_env._menhir_error);
            _menhir_env._menhir_error <- true;
            _menhir_errorcase _menhir_env (Obj.magic _menhir_stack) MenhirState1) : 'freshtv2)
    | _ ->
        assert (not _menhir_env._menhir_error);
        _menhir_env._menhir_error <- true;
        let (_menhir_env : _menhir_env) = _menhir_env in
        let (_menhir_stack : 'freshtv3) = Obj.magic _menhir_stack in
        (raise _eRR : 'freshtv4)) : 'freshtv6))

# 39 "compiler_parser.mly"
  

# 640 "compiler_parser.ml"

# 269 "/home/cauderlier/.opam/4.07.1/lib/menhir/standard.mly"
  

# 645 "compiler_parser.ml"

end
# 693 "compiler.ml"

(* Lexing *)

module Lexer = struct

(* Begin of generated lexer *)
(* Generated by OCamllex on the following input: *)
  (*
{
open Parser
}

let arg = [ 'a'-'z' 'A'-'Z' ]+
let num = [ '0'-'9' ]+
let whitespace = [ ' ' '\t' '\r' '\n' ]

rule lex = parse
  | whitespace { lex lexbuf }
  | arg as s { ARG (s) }
  | num as s { IMM (int_of_string s) }
  | '[' { LEFT_BRACKET }
  | ']' { RIGHT_BRACKET }
  | '(' { LEFT_PAREN }
  | ')' { RIGHT_PAREN }
  | '+' { ADD }
  | '-' { SUB }
  | '*' { MUL }
  | '/' { DIV }
  | eof { EOF }
*)
# 1 "compiler_lexer.mll"
 
open Parser

# 6 "compiler_lexer.ml"
let __ocaml_lex_tables = {
  Lexing.lex_base =
   "\000\000\244\255\245\255\246\255\247\255\248\255\249\255\250\255\
    \251\255\252\255\075\000\068\000\255\255";
  Lexing.lex_backtrk =
   "\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\002\000\001\000\255\255";
  Lexing.lex_default =
   "\255\255\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\255\255\255\255\000\000";
  Lexing.lex_trans =
   "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\012\000\012\000\000\000\000\000\012\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \012\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \007\000\006\000\003\000\005\000\000\000\004\000\000\000\002\000\
    \010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\
    \010\000\010\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\011\000\011\000\011\000\011\000\011\000\011\000\011\000\
    \011\000\011\000\011\000\011\000\011\000\011\000\011\000\011\000\
    \011\000\011\000\011\000\011\000\011\000\011\000\011\000\011\000\
    \011\000\011\000\011\000\009\000\000\000\008\000\000\000\000\000\
    \000\000\011\000\011\000\011\000\011\000\011\000\011\000\011\000\
    \011\000\011\000\011\000\011\000\011\000\011\000\011\000\011\000\
    \011\000\011\000\011\000\011\000\011\000\011\000\011\000\011\000\
    \011\000\011\000\011\000\010\000\010\000\010\000\010\000\010\000\
    \010\000\010\000\010\000\010\000\010\000\011\000\011\000\011\000\
    \011\000\011\000\011\000\011\000\011\000\011\000\011\000\011\000\
    \011\000\011\000\011\000\011\000\011\000\011\000\011\000\011\000\
    \011\000\011\000\011\000\011\000\011\000\011\000\011\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\011\000\011\000\011\000\
    \011\000\011\000\011\000\011\000\011\000\011\000\011\000\011\000\
    \011\000\011\000\011\000\011\000\011\000\011\000\011\000\011\000\
    \011\000\011\000\011\000\011\000\011\000\011\000\011\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000";
  Lexing.lex_check =
   "\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\000\000\000\000\255\255\255\255\000\000\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \000\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \000\000\000\000\000\000\000\000\255\255\000\000\255\255\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\255\255\000\000\255\255\255\255\
    \255\255\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\010\000\010\000\010\000\010\000\010\000\
    \010\000\010\000\010\000\010\000\010\000\011\000\011\000\011\000\
    \011\000\011\000\011\000\011\000\011\000\011\000\011\000\011\000\
    \011\000\011\000\011\000\011\000\011\000\011\000\011\000\011\000\
    \011\000\011\000\011\000\011\000\011\000\011\000\011\000\255\255\
    \255\255\255\255\255\255\255\255\255\255\011\000\011\000\011\000\
    \011\000\011\000\011\000\011\000\011\000\011\000\011\000\011\000\
    \011\000\011\000\011\000\011\000\011\000\011\000\011\000\011\000\
    \011\000\011\000\011\000\011\000\011\000\011\000\011\000\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \000\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255";
  Lexing.lex_base_code =
   "";
  Lexing.lex_backtrk_code =
   "";
  Lexing.lex_default_code =
   "";
  Lexing.lex_trans_code =
   "";
  Lexing.lex_check_code =
   "";
  Lexing.lex_code =
   "";
}

let rec lex lexbuf =
   __ocaml_lex_lex_rec lexbuf 0
and __ocaml_lex_lex_rec lexbuf __ocaml_lex_state =
  match Lexing.engine __ocaml_lex_tables __ocaml_lex_state lexbuf with
      | 0 ->
# 10 "compiler_lexer.mll"
               ( lex lexbuf )
# 124 "compiler_lexer.ml"

  | 1 ->
let
# 11 "compiler_lexer.mll"
           s
# 130 "compiler_lexer.ml"
= Lexing.sub_lexeme lexbuf lexbuf.Lexing.lex_start_pos lexbuf.Lexing.lex_curr_pos in
# 11 "compiler_lexer.mll"
             ( ARG (s) )
# 134 "compiler_lexer.ml"

  | 2 ->
let
# 12 "compiler_lexer.mll"
           s
# 140 "compiler_lexer.ml"
= Lexing.sub_lexeme lexbuf lexbuf.Lexing.lex_start_pos lexbuf.Lexing.lex_curr_pos in
# 12 "compiler_lexer.mll"
             ( IMM (int_of_string s) )
# 144 "compiler_lexer.ml"

  | 3 ->
# 13 "compiler_lexer.mll"
        ( LEFT_BRACKET )
# 149 "compiler_lexer.ml"

  | 4 ->
# 14 "compiler_lexer.mll"
        ( RIGHT_BRACKET )
# 154 "compiler_lexer.ml"

  | 5 ->
# 15 "compiler_lexer.mll"
        ( LEFT_PAREN )
# 159 "compiler_lexer.ml"

  | 6 ->
# 16 "compiler_lexer.mll"
        ( RIGHT_PAREN )
# 164 "compiler_lexer.ml"

  | 7 ->
# 17 "compiler_lexer.mll"
        ( ADD )
# 169 "compiler_lexer.ml"

  | 8 ->
# 18 "compiler_lexer.mll"
        ( SUB )
# 174 "compiler_lexer.ml"

  | 9 ->
# 19 "compiler_lexer.mll"
        ( MUL )
# 179 "compiler_lexer.ml"

  | 10 ->
# 20 "compiler_lexer.mll"
        ( DIV )
# 184 "compiler_lexer.ml"

  | 11 ->
# 21 "compiler_lexer.mll"
        ( EOF )
# 189 "compiler_lexer.ml"

  | __ocaml_lex_state -> lexbuf.Lexing.refill_buff lexbuf;
      __ocaml_lex_lex_rec lexbuf __ocaml_lex_state

;;
end
# 918 "compiler.ml"

type ast =
  | Imm of int  (* immediate value *)
  | Arg of int  (* reference to n-th argument *)
  | Add of (ast * ast) (* add first to second *)
  | Sub of (ast * ast) (* subtract second from first *)
  | Mul of (ast * ast) (* multiply first by second *)
  | Div of (ast * ast) (* divide first by second *)

module Scoping = struct

  open Parser

  exception Scoping_error of string

  let rec index_of x acc = function
    | y :: l when x = y -> acc
    | y :: l -> index_of x (acc + 1) l
    | [] -> raise (Scoping_error x)

  let rec scope args = function
    | PArg s -> Arg (index_of s 0 args)
    | PImm x -> Imm x
    | PAdd (a1, a2) -> Add (scope args a1, scope args a2)
    | PMul (a1, a2) -> Mul (scope args a1, scope args a2)
    | PSub (a1, a2) -> Sub (scope args a1, scope args a2)
    | PDiv (a1, a2) -> Div (scope args a1, scope args a2)

end

exception CompilerError of string

module type COMPILER =
  sig
    val pass1: string -> ast
    val pass2: ast -> ast
    val codeGen: ast -> string list
    val compile: string -> string list 
  end


module Compiler : COMPILER =
  struct
    let pass1 (s : string) =
      let (args, body) = Parser.func Lexer.lex (Lexing.from_string s) in
      Scoping.scope args body

    let rec pass2 = function
      | Imm i -> Imm i
      | Arg x -> Arg x
      | Add (x, y) ->
        let x' = pass2 x in
        let y' = pass2 y in
        begin match x', y' with
        | Imm i1, Imm i2 -> Imm (i1 + i2)
        | _ -> Add (x', y')
        end
      | Mul (x, y) ->
        let x' = pass2 x in
        let y' = pass2 y in
        begin match x', y' with
        | Imm i1, Imm i2 -> Imm (i1 * i2)
        | _ -> Mul (x', y')
        end
      | Sub (x, y) ->
        let x' = pass2 x in
        let y' = pass2 y in
        begin match x', y' with
        | Imm i1, Imm i2 -> Imm (i1 - i2)
        | _ -> Sub (x', y')
        end
      | Div (x, y) ->
        let x' = pass2 x in
        let y' = pass2 y in
        begin match x', y' with
        | Imm i1, Imm i2 -> Imm (i1 / i2)
        | _ -> Div (x', y')
        end

    let rec codeGenL acc = function
      | Imm i -> Printf.sprintf "IM %d" i :: acc
      | Arg i -> Printf.sprintf "AR %d" i :: acc
      | Add (x, y) ->
         "AD" :: "PO" :: "SW" :: codeGenL ("PU" :: codeGenL acc x) y
      | Mul (x, y) ->
         "MU" :: "PO" :: "SW" :: codeGenL ("PU" :: codeGenL acc x) y
      | Sub (x, y) ->
         "SU" :: "PO" :: "SW" :: codeGenL ("PU" :: codeGenL acc x) y
      | Div (x, y) ->
         "DI" :: "PO" :: "SW" :: codeGenL ("PU" :: codeGenL acc x) y

    let codeGen code = List.rev (codeGenL [] code)

    let pass3 = codeGen

    let compile code =
      codeGen(pass2(pass1 code))
  end

let rec simualte : string list * int list -> int =
  let stack = Stack.create () in
  let r0 = ref 0 in
  let r1 = ref 0 in
  function
  | ([],argumets) -> !r0
  | ("SU"::lst,argumets) ->
     r0 := !r0 - !r1;
     simualte(lst,argumets)
  | ("DI"::lst,argumets) ->
     r0 := !r0 / !r1;
     simualte(lst,argumets)
  | ("MU"::lst,argumets) ->
     r0 := !r0 * !r1;
     simualte(lst,argumets)
  | ("AD"::lst,argumets) ->
     r0 := !r0 + !r1;
     simualte(lst,argumets)
  | ("PU"::lst,argumets) ->
     Stack.push !r0 stack;
     simualte(lst,argumets)
  | ("PO"::lst,argumets) ->
     r0 := (Stack.pop stack);
     simualte(lst,argumets)
  | ("SW"::lst,argumets) ->
     let tmp = !r0 in
     r0 := !r1;
     r1 := tmp;
     simualte(lst,argumets)
  | (op::lst,argumets) ->
     let op_code = String.sub op 0 2 in
     let value =
       int_of_string
         (String.sub op 3 ((String.length op) - 3))
     in
     match op_code with
     | "IM" ->
        r0 := value;
        simualte(lst,argumets)
     | "AR" ->
        r0 := List.nth argumets value;
        simualte(lst,argumets)
     | _ -> raise (CompilerError "bad assembly")
     
____________________________________________________________________________________________________
let tokenize code =
  let rec explode string =
    if String.length string = 0 then []
    else [String.sub string 0 1] @
           explode (String.sub string 1 ((String.length string) - 1))
  in
  let specialChars =
    [
      "["; "]"; "-"; "+"; "*"; "/"; "("; ")"
    ]
  in
  let nonSpecialHelper = function
    | "" -> []
    | str -> [str]
  in
  let rec tokenizeHelper = function
    | [],currentItem, tokens ->
       tokens @ (nonSpecialHelper currentItem)
    | " "::lst, currentItem, tokens ->
       tokenizeHelper(
           lst,"",
           tokens @ nonSpecialHelper currentItem)
    | item::lst, currentItem, tokens ->
       if List.mem item specialChars then
         tokenizeHelper(
             lst, "",
             tokens @ nonSpecialHelper currentItem @ [item])
       else
         tokenizeHelper(lst, currentItem ^ item,tokens)
  in
  tokenizeHelper(explode code, "", [])

type ast =
  | Imm of int  (* immediate value *)
  | Arg of int  (* reference to n-th argument *)
  | Add of (ast * ast) (* add first to second *)
  | Sub of (ast * ast) (* subtract second from first *)
  | Mul of (ast * ast) (* multiply first by second *)
  | Div of (ast * ast) (* divide first by second *)


  
exception CompilerError of string

module type COMPILER =
  sig
    val pass1: string -> ast
    val pass2: ast -> ast
    val codeGen: ast -> string list
    val compile: string -> string list
  end

open Stack
open List

module Compiler : COMPILER =
  struct

    let shunting_yard t arg = (*Version propre*)
      let foo arb = function
        | "+" -> push (Add(pop arb, pop arb)) arb
        | "-" -> push (Sub(pop arb, pop arb)) arb
        | "*" -> push (Mul(pop arb, pop arb)) arb
        | "/" -> push (Div(pop arb, pop arb)) arb
        | _ -> () in

      let operateurs = [("+", 1); ("-", 1); ("*", 0); ("/", 0)] and
        num = init 1000 string_of_int in

      let abst = create () and
        ops  = create () in ignore (pop abst, push (Imm(0)) abst, pop ops, push "_" ops);

      for i = 0 to (Array.length t - 1) do
        match t.(i) with
          | "(" -> push "(" ops

          | s when mem s num -> push (Imm(int_of_string s)) abst

          | s when mem_assoc s operateurs -> while (not (is_empty ops) && top ops <> "(") && assoc s operateurs >= assoc (top ops) operateurs do
                          foo abst (pop ops) done;
                        push s ops

          | ")" -> while (not (is_empty ops) && top ops <> "(") do
                 foo abst(pop ops) done;
               ignore (pop ops)

          | s -> push (Arg(assoc s arg)) abst done;

      while not (is_empty ops) do
        foo abst(pop ops) done;
      if Stack.length abst <> 1 then failwith "Mauvaise expression" else top abst;;
  
    let pass1 code = print_string code;
      let rec aux1 = function
        | [] -> []
        | "]"::q -> q
        | a :: q -> aux1 q in
      let rec aux2 i = function
        | [] -> []
        | "["::q -> aux2 i q
        | "]"::q -> []
        | a :: q -> (a, i) :: aux2 (i+1) q in
      let tokens = tokenize code in
      shunting_yard (Array.of_list (aux1 tokens)) (aux2 0 tokens);;

        let rec pass2 = function
      | Imm(n) -> Imm(n)
      | Arg(n) -> Arg(n)
      | Add(g, d) -> begin match pass2 g, pass2 d with
                  | Imm(a), Imm(b) -> Imm(a+b)
                  | sg, sd -> Add(sg, sd) end
      | Sub(g, d) -> begin match pass2 g, pass2 d with
                  | Imm(a), Imm(b) -> Imm(a-b)
                  | sg, sd -> Sub(sg, sd) end
      | Mul(g, d) -> begin match pass2 g, pass2 d with
                  | Imm(a), Imm(b) -> Imm(a*b)
                  | sg, sd -> Mul(sg, sd) end
      | Div(g, d) -> begin match pass2 g, pass2 d with
                  | Imm(a), Imm(b) -> Imm(a/b)
                  | sg, sd -> Div(sg, sd) end;; 
      
    let rec codeGen = function
      | Imm(n) -> ["IM " ^ string_of_int n]
      | Arg(n) -> ["AR " ^ string_of_int n]
      | Add(g, d) -> codeGen g @ ("PU" :: (codeGen d @ ["SW"; "PO"; "AD"]))
      | Sub(g, d) -> codeGen g @ ("PU" :: (codeGen d @ ["SW"; "PO"; "SU"]))
      | Mul(g, d) -> codeGen g @ ("PU" :: (codeGen d @ ["SW"; "PO"; "MU"]))
      | Div(g, d) -> codeGen g @ ("PU" :: (codeGen d @ ["SW"; "PO"; "DI"]));;

    let compile code =
      codeGen(pass2(pass1 code))
      
  end

let rec simualte : string list * int list -> int =
  let stack = Stack.create () in
  let r0 = ref 0 in
  let r1 = ref 0 in
  function
  | ([],argumets) -> !r0
  | ("SU"::lst,argumets) ->
     r0 := !r0 - !r1;
     simualte(lst,argumets)
  | ("DI"::lst,argumets) ->
     r0 := !r0 / !r1;
     simualte(lst,argumets)
  | ("MU"::lst,argumets) ->
     r0 := !r0 * !r1;
     simualte(lst,argumets)
  | ("AD"::lst,argumets) ->
     r0 := !r0 + !r1;
     simualte(lst,argumets)
  | ("PU"::lst,argumets) ->
     Stack.push !r0 stack;
     simualte(lst,argumets)
  | ("PO"::lst,argumets) ->
     r0 := (Stack.pop stack);
     simualte(lst,argumets)
  | ("SW"::lst,argumets) ->
     let tmp = !r0 in
     r0 := !r1;
     r1 := tmp;
     simualte(lst,argumets)
  | (op::lst,argumets) ->
     let op_code = String.sub op 0 2 in
     let value =
       int_of_string
         (String.sub op 3 ((String.length op) - 3))
     in
     match op_code with
     | "IM" ->
        r0 := value;
        simualte(lst,argumets)
     | "AR" ->
        r0 := List.nth argumets value;
        simualte(lst,argumets)
     | _ -> raise (CompilerError "bad assembly")
     
_______________________________________________________________________
(* The code was partly generated using ocamllex and ocamlyacc, so don't bother reading this solution :) 
The compiler part lies at the very bottom of the program. *)

let tokenize code =
  let rec explode string =
    if String.length string = 0 then []
    else [String.sub string 0 1] @
           explode (String.sub string 1 ((String.length string) - 1))
  in
  let specialChars =
    [
      "["; "]"; "-"; "+"; "*"; "/"; "("; ")"
    ]
  in
  let nonSpecialHelper = function
    | "" -> []
    | str -> [str]
  in
  let rec tokenizeHelper = function
    | [],currentItem, tokens ->
       tokens @ (nonSpecialHelper currentItem)
    | " "::lst, currentItem, tokens ->
       tokenizeHelper(
           lst,"",
           tokens @ nonSpecialHelper currentItem)
    | item::lst, currentItem, tokens ->
       if List.mem item specialChars then
         tokenizeHelper(
             lst, "",
             tokens @ nonSpecialHelper currentItem @ [item])
       else
         tokenizeHelper(lst, currentItem ^ item,tokens)
  in
  tokenizeHelper(explode code, "", [])
  
exception CompilerError of string

let rec simualte : string list * int list -> int =
  let stack = Stack.create () in
  let r0 = ref 0 in
  let r1 = ref 0 in
  function
  | ([],argumets) -> !r0
  | ("SU"::lst,argumets) ->
     r0 := !r0 - !r1;
     simualte(lst,argumets)
  | ("DI"::lst,argumets) ->
     r0 := !r0 / !r1;
     simualte(lst,argumets)
  | ("MU"::lst,argumets) ->
     r0 := !r0 * !r1;
     simualte(lst,argumets)
  | ("AD"::lst,argumets) ->
     r0 := !r0 + !r1;
     simualte(lst,argumets)
  | ("PU"::lst,argumets) ->
     Stack.push !r0 stack;
     simualte(lst,argumets)
  | ("PO"::lst,argumets) ->
     r0 := (Stack.pop stack);
     simualte(lst,argumets)
  | ("SW"::lst,argumets) ->
     let tmp = !r0 in
     r0 := !r1;
     r1 := tmp;
     simualte(lst,argumets)
  | (op::lst,argumets) ->
     let op_code = String.sub op 0 2 in
     let value =
       int_of_string
         (String.sub op 3 ((String.length op) - 3))
     in
     match op_code with
     | "IM" ->
        r0 := value;
        simualte(lst,argumets)
     | "AR" ->
        r0 := List.nth argumets value;
        simualte(lst,argumets)
     | _ -> raise (CompilerError "bad assembly")


module Ast = struct
type ast =
  | Imm of int (* immediate value *)
  | Arg of int (* reference to n-th argument *)
  | Add of (ast * ast) (* add first to second *)
  | Sub of (ast * ast) (* subtract second from first *)
  | Mul of (ast * ast) (* multiply first by second *)
  | Div of (ast * ast) (* divide first by second *)

let rec pp ppf ast =
  match ast with
  | Imm i -> Format.fprintf ppf "%i" i
  | Arg i -> Format.fprintf ppf "Arg%i" i
  | Add (ast1, ast2) -> Format.fprintf ppf "(@[<hov 1>@[%a@]@ + @[%a@]@])" pp ast1 pp ast2
  | Sub (ast1, ast2) -> Format.fprintf ppf "(@[<hov 1>@[%a@]@ - @[%a@]@])" pp ast1 pp ast2
  | Mul (ast1, ast2) -> Format.fprintf ppf "(@[<hov 1>@[%a@]@ * @[%a@]@])" pp ast1 pp ast2
  | Div (ast1, ast2) -> Format.fprintf ppf "(@[<hov 1>@[%a@]@ / @[%a@]@])" pp ast1 pp ast2
end

(***************************************)
(***** GENERATED BY MENHIR *************)
(***************************************)

module type PARSER = sig 
  type token = 
    | RIGHT_PAR
    | RIGHT_BRACK
    | PLUS
    | MULT
    | MINUS
    | LEFT_PAR
    | LEFT_BRACK
    | IMM of (int)
    | EOF
    | DIV
    | ARG of (string)
    
  (* This exception is raised by the monolithic API functions. *)
  exception Error
  (* The monolithic API. *)
  val program: (Lexing.lexbuf -> token) -> Lexing.lexbuf -> (Ast.ast)
end

module Parser : PARSER = struct

module MenhirBasics = struct
  
  exception Error
  
  type token = 
    | RIGHT_PAR
    | RIGHT_BRACK
    | PLUS
    | MULT
    | MINUS
    | LEFT_PAR
    | LEFT_BRACK
    | IMM of (
# 26 "src/parser.mly"
       (int)
# 18 "src/parser.ml"
  )
    | EOF
    | DIV
    | ARG of (
# 25 "src/parser.mly"
       (string)
# 25 "src/parser.ml"
  )
  
end

include MenhirBasics

let _eRR =
  MenhirBasics.Error

type _menhir_env = {
  _menhir_lexer: Lexing.lexbuf -> token;
  _menhir_lexbuf: Lexing.lexbuf;
  _menhir_token: token;
  mutable _menhir_error: bool
}

and _menhir_state = 
  | MenhirState19
  | MenhirState17
  | MenhirState12
  | MenhirState10
  | MenhirState6
  | MenhirState5
  | MenhirState3
  | MenhirState1

# 1 "src/parser.mly"
  
  open Ast

    exception Parsing_error of string


  let args : (string, int) Hashtbl.t = Hashtbl.create 10

  let add_arg =
    let count = ref 0 in
    function s ->
      Hashtbl.add args s !count ; incr count



  let find_arg s =
    let n = Hashtbl.length args in
    try
      n - 1 - Hashtbl.find args s (* order of arguments is reversed *)
    with Not_found -> raise (Parsing_error (Format.sprintf "Unknown argument %s" s))

# 76 "src/parser.ml"

let rec _menhir_run17 : _menhir_env -> 'ttv_tail * _menhir_state * (Ast.ast) -> 'ttv_return =
  fun _menhir_env _menhir_stack ->
    let _menhir_env = _menhir_discard _menhir_env in
    let _tok = _menhir_env._menhir_token in
    match _tok with
    | ARG _v ->
        _menhir_run8 _menhir_env (Obj.magic _menhir_stack) MenhirState17 _v
    | IMM _v ->
        _menhir_run7 _menhir_env (Obj.magic _menhir_stack) MenhirState17 _v
    | LEFT_PAR ->
        _menhir_run6 _menhir_env (Obj.magic _menhir_stack) MenhirState17
    | _ ->
        assert (not _menhir_env._menhir_error);
        _menhir_env._menhir_error <- true;
        _menhir_errorcase _menhir_env (Obj.magic _menhir_stack) MenhirState17

and _menhir_run19 : _menhir_env -> 'ttv_tail * _menhir_state * (Ast.ast) -> 'ttv_return =
  fun _menhir_env _menhir_stack ->
    let _menhir_env = _menhir_discard _menhir_env in
    let _tok = _menhir_env._menhir_token in
    match _tok with
    | ARG _v ->
        _menhir_run8 _menhir_env (Obj.magic _menhir_stack) MenhirState19 _v
    | IMM _v ->
        _menhir_run7 _menhir_env (Obj.magic _menhir_stack) MenhirState19 _v
    | LEFT_PAR ->
        _menhir_run6 _menhir_env (Obj.magic _menhir_stack) MenhirState19
    | _ ->
        assert (not _menhir_env._menhir_error);
        _menhir_env._menhir_error <- true;
        _menhir_errorcase _menhir_env (Obj.magic _menhir_stack) MenhirState19

and _menhir_goto_expression : _menhir_env -> 'ttv_tail -> _menhir_state -> (Ast.ast) -> 'ttv_return =
  fun _menhir_env _menhir_stack _menhir_s _v ->
    let _menhir_stack = (_menhir_stack, _menhir_s, _v) in
    match _menhir_s with
    | MenhirState6 ->
        let _menhir_stack = Obj.magic _menhir_stack in
        assert (not _menhir_env._menhir_error);
        let _tok = _menhir_env._menhir_token in
        (match _tok with
        | MINUS ->
            _menhir_run19 _menhir_env (Obj.magic _menhir_stack)
        | PLUS ->
            _menhir_run17 _menhir_env (Obj.magic _menhir_stack)
        | RIGHT_PAR ->
            let _menhir_stack = Obj.magic _menhir_stack in
            let _menhir_env = _menhir_discard _menhir_env in
            let _menhir_stack = Obj.magic _menhir_stack in
            let ((_menhir_stack, _menhir_s), _, (e : (Ast.ast))) = _menhir_stack in
            let _v : (Ast.ast) = 
# 58 "src/parser.mly"
                                  ( e )
# 131 "src/parser.ml"
             in
            _menhir_goto_factor _menhir_env _menhir_stack _menhir_s _v
        | _ ->
            assert (not _menhir_env._menhir_error);
            _menhir_env._menhir_error <- true;
            let _menhir_stack = Obj.magic _menhir_stack in
            let (_menhir_stack, _menhir_s, _) = _menhir_stack in
            _menhir_errorcase _menhir_env (Obj.magic _menhir_stack) _menhir_s)
    | MenhirState5 ->
        let _menhir_stack = Obj.magic _menhir_stack in
        assert (not _menhir_env._menhir_error);
        let _tok = _menhir_env._menhir_token in
        (match _tok with
        | EOF ->
            let _menhir_stack = Obj.magic _menhir_stack in
            let _menhir_stack = Obj.magic _menhir_stack in
            let ((_menhir_stack, _, _), _, (e : (Ast.ast))) = _menhir_stack in
            let _v : (Ast.ast) = 
# 39 "src/parser.mly"
                                   ( e )
# 152 "src/parser.ml"
             in
            let _menhir_stack = Obj.magic _menhir_stack in
            let _menhir_stack = Obj.magic _menhir_stack in
            let (_1 : (Ast.ast)) = _v in
            Obj.magic _1
        | MINUS ->
            _menhir_run19 _menhir_env (Obj.magic _menhir_stack)
        | PLUS ->
            _menhir_run17 _menhir_env (Obj.magic _menhir_stack)
        | _ ->
            assert (not _menhir_env._menhir_error);
            _menhir_env._menhir_error <- true;
            let _menhir_stack = Obj.magic _menhir_stack in
            let (_menhir_stack, _menhir_s, _) = _menhir_stack in
            _menhir_errorcase _menhir_env (Obj.magic _menhir_stack) _menhir_s)
    | _ ->
        _menhir_fail ()

and _menhir_run10 : _menhir_env -> 'ttv_tail * _menhir_state * (Ast.ast) -> 'ttv_return =
  fun _menhir_env _menhir_stack ->
    let _menhir_env = _menhir_discard _menhir_env in
    let _tok = _menhir_env._menhir_token in
    match _tok with
    | ARG _v ->
        _menhir_run8 _menhir_env (Obj.magic _menhir_stack) MenhirState10 _v
    | IMM _v ->
        _menhir_run7 _menhir_env (Obj.magic _menhir_stack) MenhirState10 _v
    | LEFT_PAR ->
        _menhir_run6 _menhir_env (Obj.magic _menhir_stack) MenhirState10
    | _ ->
        assert (not _menhir_env._menhir_error);
        _menhir_env._menhir_error <- true;
        _menhir_errorcase _menhir_env (Obj.magic _menhir_stack) MenhirState10

and _menhir_run12 : _menhir_env -> 'ttv_tail * _menhir_state * (Ast.ast) -> 'ttv_return =
  fun _menhir_env _menhir_stack ->
    let _menhir_env = _menhir_discard _menhir_env in
    let _tok = _menhir_env._menhir_token in
    match _tok with
    | ARG _v ->
        _menhir_run8 _menhir_env (Obj.magic _menhir_stack) MenhirState12 _v
    | IMM _v ->
        _menhir_run7 _menhir_env (Obj.magic _menhir_stack) MenhirState12 _v
    | LEFT_PAR ->
        _menhir_run6 _menhir_env (Obj.magic _menhir_stack) MenhirState12
    | _ ->
        assert (not _menhir_env._menhir_error);
        _menhir_env._menhir_error <- true;
        _menhir_errorcase _menhir_env (Obj.magic _menhir_stack) MenhirState12

and _menhir_goto_term : _menhir_env -> 'ttv_tail -> _menhir_state -> (Ast.ast) -> 'ttv_return =
  fun _menhir_env _menhir_stack _menhir_s _v ->
    let _menhir_stack = (_menhir_stack, _menhir_s, _v) in
    match _menhir_s with
    | MenhirState5 | MenhirState6 ->
        let _menhir_stack = Obj.magic _menhir_stack in
        assert (not _menhir_env._menhir_error);
        let _tok = _menhir_env._menhir_token in
        (match _tok with
        | DIV ->
            _menhir_run12 _menhir_env (Obj.magic _menhir_stack)
        | MULT ->
            _menhir_run10 _menhir_env (Obj.magic _menhir_stack)
        | EOF | MINUS | PLUS | RIGHT_PAR ->
            let _menhir_stack = Obj.magic _menhir_stack in
            let (_menhir_stack, _menhir_s, (t : (Ast.ast))) = _menhir_stack in
            let _v : (Ast.ast) = 
# 46 "src/parser.mly"
         ( t )
# 222 "src/parser.ml"
             in
            _menhir_goto_expression _menhir_env _menhir_stack _menhir_s _v
        | _ ->
            assert (not _menhir_env._menhir_error);
            _menhir_env._menhir_error <- true;
            let _menhir_stack = Obj.magic _menhir_stack in
            let (_menhir_stack, _menhir_s, _) = _menhir_stack in
            _menhir_errorcase _menhir_env (Obj.magic _menhir_stack) _menhir_s)
    | MenhirState17 ->
        let _menhir_stack = Obj.magic _menhir_stack in
        assert (not _menhir_env._menhir_error);
        let _tok = _menhir_env._menhir_token in
        (match _tok with
        | DIV ->
            _menhir_run12 _menhir_env (Obj.magic _menhir_stack)
        | MULT ->
            _menhir_run10 _menhir_env (Obj.magic _menhir_stack)
        | EOF | MINUS | PLUS | RIGHT_PAR ->
            let _menhir_stack = Obj.magic _menhir_stack in
            let ((_menhir_stack, _menhir_s, (e : (Ast.ast))), _, (t : (Ast.ast))) = _menhir_stack in
            let _v : (Ast.ast) = 
# 47 "src/parser.mly"
                           ( Add (e, t) )
# 246 "src/parser.ml"
             in
            _menhir_goto_expression _menhir_env _menhir_stack _menhir_s _v
        | _ ->
            assert (not _menhir_env._menhir_error);
            _menhir_env._menhir_error <- true;
            let _menhir_stack = Obj.magic _menhir_stack in
            let (_menhir_stack, _menhir_s, _) = _menhir_stack in
            _menhir_errorcase _menhir_env (Obj.magic _menhir_stack) _menhir_s)
    | MenhirState19 ->
        let _menhir_stack = Obj.magic _menhir_stack in
        assert (not _menhir_env._menhir_error);
        let _tok = _menhir_env._menhir_token in
        (match _tok with
        | DIV ->
            _menhir_run12 _menhir_env (Obj.magic _menhir_stack)
        | MULT ->
            _menhir_run10 _menhir_env (Obj.magic _menhir_stack)
        | EOF | MINUS | PLUS | RIGHT_PAR ->
            let _menhir_stack = Obj.magic _menhir_stack in
            let ((_menhir_stack, _menhir_s, (e : (Ast.ast))), _, (t : (Ast.ast))) = _menhir_stack in
            let _v : (Ast.ast) = 
# 48 "src/parser.mly"
                            ( Sub (e,t) )
# 270 "src/parser.ml"
             in
            _menhir_goto_expression _menhir_env _menhir_stack _menhir_s _v
        | _ ->
            assert (not _menhir_env._menhir_error);
            _menhir_env._menhir_error <- true;
            let _menhir_stack = Obj.magic _menhir_stack in
            let (_menhir_stack, _menhir_s, _) = _menhir_stack in
            _menhir_errorcase _menhir_env (Obj.magic _menhir_stack) _menhir_s)
    | _ ->
        _menhir_fail ()

and _menhir_goto_factor : _menhir_env -> 'ttv_tail -> _menhir_state -> (Ast.ast) -> 'ttv_return =
  fun _menhir_env _menhir_stack _menhir_s _v ->
    match _menhir_s with
    | MenhirState10 ->
        let _menhir_stack = Obj.magic _menhir_stack in
        let _menhir_stack = Obj.magic _menhir_stack in
        let (f : (Ast.ast)) = _v in
        let (_menhir_stack, _menhir_s, (t : (Ast.ast))) = _menhir_stack in
        let _v : (Ast.ast) = 
# 52 "src/parser.mly"
                       ( Mul (t, f) )
# 293 "src/parser.ml"
         in
        _menhir_goto_term _menhir_env _menhir_stack _menhir_s _v
    | MenhirState12 ->
        let _menhir_stack = Obj.magic _menhir_stack in
        let _menhir_stack = Obj.magic _menhir_stack in
        let (f : (Ast.ast)) = _v in
        let (_menhir_stack, _menhir_s, (t : (Ast.ast))) = _menhir_stack in
        let _v : (Ast.ast) = 
# 53 "src/parser.mly"
                      ( Div (t, f) )
# 304 "src/parser.ml"
         in
        _menhir_goto_term _menhir_env _menhir_stack _menhir_s _v
    | MenhirState5 | MenhirState19 | MenhirState17 | MenhirState6 ->
        let _menhir_stack = Obj.magic _menhir_stack in
        let _menhir_stack = Obj.magic _menhir_stack in
        let (f : (Ast.ast)) = _v in
        let _v : (Ast.ast) = 
# 51 "src/parser.mly"
           ( f )
# 314 "src/parser.ml"
         in
        _menhir_goto_term _menhir_env _menhir_stack _menhir_s _v
    | _ ->
        _menhir_fail ()

and _menhir_fail : unit -> 'a =
  fun () ->
    Printf.fprintf stderr "Internal failure -- please contact the parser generator's developers.\n%!";
    assert false

and _menhir_run6 : _menhir_env -> 'ttv_tail -> _menhir_state -> 'ttv_return =
  fun _menhir_env _menhir_stack _menhir_s ->
    let _menhir_stack = (_menhir_stack, _menhir_s) in
    let _menhir_env = _menhir_discard _menhir_env in
    let _tok = _menhir_env._menhir_token in
    match _tok with
    | ARG _v ->
        _menhir_run8 _menhir_env (Obj.magic _menhir_stack) MenhirState6 _v
    | IMM _v ->
        _menhir_run7 _menhir_env (Obj.magic _menhir_stack) MenhirState6 _v
    | LEFT_PAR ->
        _menhir_run6 _menhir_env (Obj.magic _menhir_stack) MenhirState6
    | _ ->
        assert (not _menhir_env._menhir_error);
        _menhir_env._menhir_error <- true;
        _menhir_errorcase _menhir_env (Obj.magic _menhir_stack) MenhirState6

and _menhir_run7 : _menhir_env -> 'ttv_tail -> _menhir_state -> (
# 26 "src/parser.mly"
       (int)
# 345 "src/parser.ml"
) -> 'ttv_return =
  fun _menhir_env _menhir_stack _menhir_s _v ->
    let _menhir_env = _menhir_discard _menhir_env in
    let _menhir_stack = Obj.magic _menhir_stack in
    let (n : (
# 26 "src/parser.mly"
       (int)
# 353 "src/parser.ml"
    )) = _v in
    let _v : (Ast.ast) = 
# 56 "src/parser.mly"
        ( Imm n )
# 358 "src/parser.ml"
     in
    _menhir_goto_factor _menhir_env _menhir_stack _menhir_s _v

and _menhir_run8 : _menhir_env -> 'ttv_tail -> _menhir_state -> (
# 25 "src/parser.mly"
       (string)
# 365 "src/parser.ml"
) -> 'ttv_return =
  fun _menhir_env _menhir_stack _menhir_s _v ->
    let _menhir_env = _menhir_discard _menhir_env in
    let _menhir_stack = Obj.magic _menhir_stack in
    let (a : (
# 25 "src/parser.mly"
       (string)
# 373 "src/parser.ml"
    )) = _v in
    let _v : (Ast.ast) = 
# 57 "src/parser.mly"
        ( Arg (find_arg a) )
# 378 "src/parser.ml"
     in
    _menhir_goto_factor _menhir_env _menhir_stack _menhir_s _v

and _menhir_goto_args : _menhir_env -> 'ttv_tail -> _menhir_state -> (unit) -> 'ttv_return =
  fun _menhir_env _menhir_stack _menhir_s _v ->
    let _menhir_stack = (_menhir_stack, _menhir_s, _v) in
    match _menhir_s with
    | MenhirState3 ->
        let _menhir_stack = Obj.magic _menhir_stack in
        let _menhir_stack = Obj.magic _menhir_stack in
        let ((_menhir_stack, _menhir_s, (a : (
# 25 "src/parser.mly"
       (string)
# 392 "src/parser.ml"
        ))), _, _) = _menhir_stack in
        let _v : (unit) = 
# 43 "src/parser.mly"
               ( add_arg a )
# 397 "src/parser.ml"
         in
        _menhir_goto_args _menhir_env _menhir_stack _menhir_s _v
    | MenhirState1 ->
        let _menhir_stack = Obj.magic _menhir_stack in
        assert (not _menhir_env._menhir_error);
        let _tok = _menhir_env._menhir_token in
        (match _tok with
        | ARG _v ->
            _menhir_run8 _menhir_env (Obj.magic _menhir_stack) MenhirState5 _v
        | IMM _v ->
            _menhir_run7 _menhir_env (Obj.magic _menhir_stack) MenhirState5 _v
        | LEFT_PAR ->
            _menhir_run6 _menhir_env (Obj.magic _menhir_stack) MenhirState5
        | _ ->
            assert (not _menhir_env._menhir_error);
            _menhir_env._menhir_error <- true;
            _menhir_errorcase _menhir_env (Obj.magic _menhir_stack) MenhirState5)
    | _ ->
        _menhir_fail ()

and _menhir_errorcase : _menhir_env -> 'ttv_tail -> _menhir_state -> 'ttv_return =
  fun _menhir_env _menhir_stack _menhir_s ->
    match _menhir_s with
    | MenhirState19 ->
        let _menhir_stack = Obj.magic _menhir_stack in
        let (_menhir_stack, _menhir_s, _) = _menhir_stack in
        _menhir_errorcase _menhir_env (Obj.magic _menhir_stack) _menhir_s
    | MenhirState17 ->
        let _menhir_stack = Obj.magic _menhir_stack in
        let (_menhir_stack, _menhir_s, _) = _menhir_stack in
        _menhir_errorcase _menhir_env (Obj.magic _menhir_stack) _menhir_s
    | MenhirState12 ->
        let _menhir_stack = Obj.magic _menhir_stack in
        let (_menhir_stack, _menhir_s, _) = _menhir_stack in
        _menhir_errorcase _menhir_env (Obj.magic _menhir_stack) _menhir_s
    | MenhirState10 ->
        let _menhir_stack = Obj.magic _menhir_stack in
        let (_menhir_stack, _menhir_s, _) = _menhir_stack in
        _menhir_errorcase _menhir_env (Obj.magic _menhir_stack) _menhir_s
    | MenhirState6 ->
        let _menhir_stack = Obj.magic _menhir_stack in
        let (_menhir_stack, _menhir_s) = _menhir_stack in
        _menhir_errorcase _menhir_env (Obj.magic _menhir_stack) _menhir_s
    | MenhirState5 ->
        let _menhir_stack = Obj.magic _menhir_stack in
        let (_menhir_stack, _menhir_s, _) = _menhir_stack in
        _menhir_errorcase _menhir_env (Obj.magic _menhir_stack) _menhir_s
    | MenhirState3 ->
        let _menhir_stack = Obj.magic _menhir_stack in
        let (_menhir_stack, _menhir_s, _) = _menhir_stack in
        _menhir_errorcase _menhir_env (Obj.magic _menhir_stack) _menhir_s
    | MenhirState1 ->
        let _menhir_stack = Obj.magic _menhir_stack in
        raise _eRR

and _menhir_run2 : _menhir_env -> 'ttv_tail -> _menhir_state -> 'ttv_return =
  fun _menhir_env _menhir_stack _menhir_s ->
    let _menhir_env = _menhir_discard _menhir_env in
    let _menhir_stack = Obj.magic _menhir_stack in
    let _v : (unit) = 
# 42 "src/parser.mly"
              ( () )
# 460 "src/parser.ml"
     in
    _menhir_goto_args _menhir_env _menhir_stack _menhir_s _v

and _menhir_run3 : _menhir_env -> 'ttv_tail -> _menhir_state -> (
# 25 "src/parser.mly"
       (string)
# 467 "src/parser.ml"
) -> 'ttv_return =
  fun _menhir_env _menhir_stack _menhir_s _v ->
    let _menhir_stack = (_menhir_stack, _menhir_s, _v) in
    let _menhir_env = _menhir_discard _menhir_env in
    let _tok = _menhir_env._menhir_token in
    match _tok with
    | ARG _v ->
        _menhir_run3 _menhir_env (Obj.magic _menhir_stack) MenhirState3 _v
    | RIGHT_BRACK ->
        _menhir_run2 _menhir_env (Obj.magic _menhir_stack) MenhirState3
    | _ ->
        assert (not _menhir_env._menhir_error);
        _menhir_env._menhir_error <- true;
        _menhir_errorcase _menhir_env (Obj.magic _menhir_stack) MenhirState3

and _menhir_discard : _menhir_env -> _menhir_env =
  fun _menhir_env ->
    let lexer = _menhir_env._menhir_lexer in
    let lexbuf = _menhir_env._menhir_lexbuf in
    let _tok = lexer lexbuf in
    {
      _menhir_lexer = lexer;
      _menhir_lexbuf = lexbuf;
      _menhir_token = _tok;
      _menhir_error = false;
    }

and program : (Lexing.lexbuf -> token) -> Lexing.lexbuf -> (Ast.ast) =
  fun lexer lexbuf ->
    let _menhir_env = {
      _menhir_lexer = lexer;
      _menhir_lexbuf = lexbuf;
      _menhir_token = Obj.magic ();
      _menhir_error = false;
    } in
    Obj.magic (let _menhir_stack = ((), _menhir_env._menhir_lexbuf.Lexing.lex_curr_p) in
    let _menhir_env = _menhir_discard _menhir_env in
    let _tok = _menhir_env._menhir_token in
    match _tok with
    | LEFT_BRACK ->
        let _menhir_stack = Obj.magic _menhir_stack in
        let _menhir_env = _menhir_discard _menhir_env in
        let _tok = _menhir_env._menhir_token in
        (match _tok with
        | ARG _v ->
            _menhir_run3 _menhir_env (Obj.magic _menhir_stack) MenhirState1 _v
        | RIGHT_BRACK ->
            _menhir_run2 _menhir_env (Obj.magic _menhir_stack) MenhirState1
        | _ ->
            assert (not _menhir_env._menhir_error);
            _menhir_env._menhir_error <- true;
            _menhir_errorcase _menhir_env (Obj.magic _menhir_stack) MenhirState1)
    | _ ->
        assert (not _menhir_env._menhir_error);
        _menhir_env._menhir_error <- true;
        let _menhir_stack = Obj.magic _menhir_stack in
        raise _eRR)

# 269 "<standard.mly>"
  

# 529 "src/parser.ml"
end

(***************************************)
(***** GENERATED BY OCAMLLEX ***********)
(***************************************)

module Lexer = struct
# 1 "src/lexer.mll"
 
  open Parser

  exception Lexing_error of string

  let string_buffer = Buffer.create 64

# 10 "src/lexer.ml"
let __ocaml_lex_tables = {
  Lexing.lex_base =
   "\000\000\243\255\244\255\245\255\246\255\247\255\248\255\249\255\
    \250\255\251\255\058\000\253\255\133\000\002\000";
  Lexing.lex_backtrk =
   "\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\003\000\255\255\001\000\000\000";
  Lexing.lex_default =
   "\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\255\255\000\000\255\255\255\255";
  Lexing.lex_trans =
   "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\013\000\013\000\013\000\013\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \013\000\000\000\013\000\000\000\000\000\000\000\000\000\000\000\
    \007\000\006\000\003\000\005\000\000\000\004\000\000\000\002\000\
    \012\000\012\000\012\000\012\000\012\000\012\000\012\000\012\000\
    \012\000\012\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\
    \010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\
    \010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\
    \010\000\010\000\010\000\009\000\000\000\008\000\000\000\000\000\
    \000\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\
    \010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\
    \010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\
    \010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\
    \010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\
    \010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\
    \010\000\010\000\010\000\010\000\010\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\010\000\010\000\010\000\010\000\010\000\
    \010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\
    \010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\
    \010\000\010\000\010\000\010\000\010\000\012\000\012\000\012\000\
    \012\000\012\000\012\000\012\000\012\000\012\000\012\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \011\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000";
  Lexing.lex_check =
   "\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\000\000\000\000\013\000\013\000\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \000\000\255\255\013\000\255\255\255\255\255\255\255\255\255\255\
    \000\000\000\000\000\000\000\000\255\255\000\000\255\255\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\255\255\000\000\255\255\255\255\
    \255\255\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\010\000\010\000\010\000\010\000\010\000\
    \010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\
    \010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\
    \010\000\010\000\010\000\010\000\010\000\255\255\255\255\255\255\
    \255\255\255\255\255\255\010\000\010\000\010\000\010\000\010\000\
    \010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\
    \010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\
    \010\000\010\000\010\000\010\000\010\000\012\000\012\000\012\000\
    \012\000\012\000\012\000\012\000\012\000\012\000\012\000\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \000\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255";
  Lexing.lex_base_code =
   "";
  Lexing.lex_backtrk_code =
   "";
  Lexing.lex_default_code =
   "";
  Lexing.lex_trans_code =
   "";
  Lexing.lex_check_code =
   "";
  Lexing.lex_code =
   "";
}

let rec next_token lexbuf =
   __ocaml_lex_next_token_rec lexbuf 0
and __ocaml_lex_next_token_rec lexbuf __ocaml_lex_state =
  match Lexing.engine __ocaml_lex_tables __ocaml_lex_state lexbuf with
      | 0 ->
# 16 "src/lexer.mll"
           ( next_token lexbuf )
# 142 "src/lexer.ml"

  | 1 ->
let
# 17 "src/lexer.mll"
              s
# 148 "src/lexer.ml"
= Lexing.sub_lexeme lexbuf lexbuf.Lexing.lex_start_pos lexbuf.Lexing.lex_curr_pos in
# 17 "src/lexer.mll"
                ( try IMM (int_of_string s) with _ -> raise (Lexing_error (Format.sprintf "constant too large: %s" s)))
# 152 "src/lexer.ml"

  | 2 ->
# 18 "src/lexer.mll"
        ( EOF )
# 157 "src/lexer.ml"

  | 3 ->
let
# 19 "src/lexer.mll"
                id
# 163 "src/lexer.ml"
= Lexing.sub_lexeme lexbuf lexbuf.Lexing.lex_start_pos lexbuf.Lexing.lex_curr_pos in
# 19 "src/lexer.mll"
                   ( ARG id )
# 167 "src/lexer.ml"

  | 4 ->
# 20 "src/lexer.mll"
        ( LEFT_BRACK )
# 172 "src/lexer.ml"

  | 5 ->
# 21 "src/lexer.mll"
        ( RIGHT_BRACK )
# 177 "src/lexer.ml"

  | 6 ->
# 22 "src/lexer.mll"
        ( LEFT_PAR )
# 182 "src/lexer.ml"

  | 7 ->
# 23 "src/lexer.mll"
        ( RIGHT_PAR )
# 187 "src/lexer.ml"

  | 8 ->
# 24 "src/lexer.mll"
        ( PLUS )
# 192 "src/lexer.ml"

  | 9 ->
# 25 "src/lexer.mll"
        ( MINUS )
# 197 "src/lexer.ml"

  | 10 ->
# 26 "src/lexer.mll"
        ( MULT )
# 202 "src/lexer.ml"

  | 11 ->
# 27 "src/lexer.mll"
        ( DIV )
# 207 "src/lexer.ml"

  | 12 ->
let
# 28 "src/lexer.mll"
         c
# 213 "src/lexer.ml"
= Lexing.sub_lexeme_char lexbuf lexbuf.Lexing.lex_start_pos in
# 28 "src/lexer.mll"
           ( raise (Lexing_error (Format.sprintf "illegal character: %c" c)))
# 217 "src/lexer.ml"

  | __ocaml_lex_state -> lexbuf.Lexing.refill_buff lexbuf;
      __ocaml_lex_next_token_rec lexbuf __ocaml_lex_state

;;

# 30 "src/lexer.mll"
 


# 228 "src/lexer.ml"

end

module Assembly = struct
type instruction =
   | IM of int (* load the constant value n into R0 *)
   | AR of int (* load the n-th input argument into R0 *)
   | SW        (* swap R0 and R1 *)
   | PU        (* push R0 onto the stack *)
   | PO        (* pop the top value off of the stack into R0 *)
   | AD        (* add R1 to R0 and put the result in R0 *)
   | SU        (* subtract R1 from R0 and put the result in R0 *)
   | MU        (* multiply R0 by R1 and put the result in R0 *)
   | DI        (* divide R0 by R1 and put the result in R0 *)

let pp ppf instruction = match instruction with
   | IM i -> Format.fprintf ppf "IM %i" i
   | AR i -> Format.fprintf ppf "AR %i" i
   | SW -> Format.fprintf ppf "SW"
   | PU -> Format.fprintf ppf "PU"
   | PO -> Format.fprintf ppf "PO"
   | AD -> Format.fprintf ppf "AD"
   | SU -> Format.fprintf ppf "SU"
   | MU -> Format.fprintf ppf "MU"
   | DI -> Format.fprintf ppf "DI"

let to_string (instruction : instruction) : string = match instruction with
  | IM i -> "IM " ^ (string_of_int i)
  | AR i -> "AR " ^ (string_of_int i)
  | SW -> "SW"
  | PU -> "PU"
  | PO -> "PO"
  | AD -> "AD"
  | SU -> "SU"
  | MU -> "MU"
  | DI -> "DI"
end

open Ast

module type COMPILER = sig
  val pass1 : string -> ast

  val pass2 : ast -> ast

  val instructions : ast -> Assembly.instruction list

  val codeGen : ast -> string list

  val compile : string -> string list
end

module Compiler : COMPILER = struct

  let pass1 s =
    let lb = Lexing.from_string s in
    Parser.program Lexer.next_token lb


  let rec pass2 = 
    let op_and_construct ast = match ast with
      | Imm _ | Arg _ -> failwith "Not an operation"
      | Add _ -> ( + ), fun a1 a2 -> Add(a1, a2)
      | Sub _ -> ( - ), fun a1 a2 -> Sub(a1, a2)
      | Mul _ -> ( * ), fun a1 a2 -> Mul(a1, a2)
      | Div _ -> ( / ), fun a1 a2 -> Div(a1, a2)
    in fun ast -> match ast with
    | Imm i -> Imm i
    | Arg i -> Arg i
    | Add (ast1, ast2) | Sub (ast1, ast2) | Mul (ast1, ast2) | Div (ast1, ast2) -> 
      let op, constructor = op_and_construct ast in
      match pass2 ast1, pass2 ast2 with
      | Imm i, Imm j -> Imm (op i j)
      | ast1, ast2 -> constructor ast1 ast2

  let rec instructions =
    let open Assembly in
    let operation ast = match ast with
      | Imm _ | Arg _ -> failwith "Not an operation"
      | Add _ -> AD
      | Sub _ -> SU
      | Mul _ -> MU
      | Div _ -> DI
    in fun ast -> match ast with
    | Imm n -> [IM n]
    | Arg n -> [AR n]
    | Add (a1, a2) | Sub (a1, a2) | Mul (a1, a2) | Div (a1, a2) ->
    (instructions a1) @ PU :: (instructions a2) @ SW :: PO :: [operation ast]

  let codeGen ast = List.map Assembly.to_string (instructions ast)

  let compile code = code |> pass1 |> pass2 |> codeGen
end
